{
  "topicId": "kotlin_coroutines",
  "quizQuestions": [
    {"id": "kotlin_coroutines_quiz_1", "questionText": "Which of the following is NOT a Kotlin coroutine dispatcher?", "type": "MCQ", "options": ["Dispatchers.Network", "Dispatchers.Main", "Dispatchers.Default", "Dispatchers.IO"], "correctAnswer": "Dispatchers.Network", "explanation": "Kotlin doesn't have a Dispatchers.Network. The standard dispatchers are Dispatchers.Main (UI thread), Dispatchers.IO (for IO operations), Dispatchers.Default (for CPU-intensive work), and Dispatchers.Unconfined.", "difficulty": "EASY"},
    
    {"id": "kotlin_coroutines_quiz_2", "questionText": "What does the suspend keyword indicate in Kotlin?", "type": "MCQ", "options": ["The function can be paused and resumed later without blocking the thread", "The function should be executed on a background thread", "The function must be called from within a coroutine", "The function will execute synchronously"], "correctAnswer": "The function can be paused and resumed later without blocking the thread", "explanation": "The suspend keyword marks a function as suspendable - it can pause execution at suspension points without blocking the underlying thread. Suspended functions must be called from a coroutine context or another suspend function.", "difficulty": "EASY"},
    
    {"id": "kotlin_coroutines_quiz_3", "questionText": "Which coroutine builder should you use when you need to return a result from a coroutine?", "type": "MCQ", "options": ["async", "launch", "runBlocking", "withContext"], "correctAnswer": "async", "explanation": "The async builder returns a Deferred<T> object that represents a future result, which can be retrieved using await(). This makes it suitable when you need to compute a value asynchronously and use it later.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_coroutines_quiz_4", "questionText": "What happens when an exception occurs in a coroutine launched with launch?", "type": "MCQ", "options": ["It propagates to the parent coroutine and cancels it", "It is silently ignored", "It is stored and thrown only when explicitly requested", "It immediately crashes the application"], "correctAnswer": "It propagates to the parent coroutine and cancels it", "explanation": "By default, uncaught exceptions in launch are treated as uncaught exceptions in threads - they propagate to the parent coroutine, cancel it and its other children. This behavior follows structured concurrency principles.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_coroutines_quiz_5", "questionText": "What is the primary purpose of supervisorScope in Kotlin coroutines?", "type": "MCQ", "options": ["To allow child coroutines to fail independently without cancelling siblings", "To enforce sequential execution of coroutines", "To limit the number of concurrent coroutines", "To provide direct access to the thread scheduler"], "correctAnswer": "To allow child coroutines to fail independently without cancelling siblings", "explanation": "supervisorScope creates a coroutine scope that doesn't cancel when one of its children fails. This is useful when you want to continue executing other tasks even if some of them fail, like in parallel API requests where partial data is better than none.", "difficulty": "HARD"}
  ]
}