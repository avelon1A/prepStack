{
  "topicId": "kotlin_functional",
  "quizQuestions": [
    {"id": "kotlin_functional_quiz_1", "questionText": "Which of the following is a higher-order function in Kotlin?", "type": "MCQ", "options": ["map()", "toString()", "equals()", "hashCode()"], "correctAnswer": "map()", "explanation": "The map() function is a higher-order function because it takes another function as a parameter (the transformation function to apply to each element). The other functions don't take or return functions.", "difficulty": "EASY"},
    
    {"id": "kotlin_functional_quiz_2", "questionText": "What is the result of the following code?\n\nval numbers = listOf(1, 2, 3, 4, 5)\nval result = numbers.filter { it % 2 == 0 }.map { it * 2 }", "type": "MCQ", "options": ["[4, 8]", "[1, 2, 3, 4, 5]", "[2, 4, 6, 8, 10]", "[2, 6, 10]"], "correctAnswer": "[4, 8]", "explanation": "The filter operation selects only the even numbers from the list (2, 4), and then the map operation multiplies each of them by 2, resulting in [4, 8].", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_functional_quiz_3", "questionText": "What's the main advantage of using sequences over collections for multiple operations?", "type": "MCQ", "options": ["Improved performance through lazy evaluation", "Thread safety", "Lower memory footprint in all cases", "Automatic parallel processing"], "correctAnswer": "Improved performance through lazy evaluation", "explanation": "Sequences evaluate operations lazily and avoid creating intermediate collections, which can significantly improve performance when processing large collections with multiple operations. They don't provide thread safety or automatic parallel processing.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_functional_quiz_4", "questionText": "Which collection operation would you use to transform a list of lists into a single flattened list?", "type": "MCQ", "options": ["flatMap", "flatten", "reduce", "mapNotNull"], "correctAnswer": "flatten", "explanation": "The flatten() function is specifically designed to convert a nested collection (like a list of lists) into a single flattened collection. flatMap() would also work if combined with an identity function, but flatten() is more direct for this specific case.", "difficulty": "EASY"},
    
    {"id": "kotlin_functional_quiz_5", "questionText": "What does the 'inline' keyword do when applied to higher-order functions?", "type": "MCQ", "options": ["Copies the function body and lambda arguments to the call site", "Makes the function execute on a separate thread", "Prevents the function from being overridden", "Forces the compiler to optimize the function"], "correctAnswer": "Copies the function body and lambda arguments to the call site", "explanation": "The inline keyword instructs the compiler to copy the function's body and its lambda parameters to each call site, eliminating the overhead of function calls and lambda object creation. This is particularly useful for higher-order functions that are called frequently.", "difficulty": "HARD"}
  ]
}