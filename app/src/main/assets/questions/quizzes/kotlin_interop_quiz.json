{
  "topicId": "kotlin_interop",
  "quizQuestions": [
    {"id": "kotlin_interop_quiz_1", "questionText": "How do Kotlin's nullable types appear when called from Java code?", "type": "MCQ", "options": ["As regular types without nullability information", "As Optional<T> types", "As @Nullable annotated types", "They cannot be accessed from Java"], "correctAnswer": "As regular types without nullability information", "explanation": "When Java code accesses Kotlin's nullable types, they appear as regular Java types without nullability information. This is because Java's type system doesn't natively enforce null safety. The nullability information is lost at the interoperability boundary.", "difficulty": "EASY"},
    
    {"id": "kotlin_interop_quiz_2", "questionText": "Which annotation should you use to make a Kotlin companion object method accessible as a static method in Java?", "type": "MCQ", "options": ["@JvmStatic", "@JvmField", "@JvmOverloads", "@Static"], "correctAnswer": "@JvmStatic", "explanation": "The @JvmStatic annotation tells the Kotlin compiler to generate static methods for functions in companion objects or object declarations, making them accessible as static methods in Java rather than requiring access through the Companion instance.", "difficulty": "EASY"},
    
    {"id": "kotlin_interop_quiz_3", "questionText": "What does the @JvmOverloads annotation do in Kotlin?", "type": "MCQ", "options": ["Generates method overloads for default parameter values", "Overrides Java methods from Kotlin", "Allows overloading operators for Java callers", "Changes method visibility for Java code"], "correctAnswer": "Generates method overloads for default parameter values", "explanation": "The @JvmOverloads annotation instructs the Kotlin compiler to generate multiple overloaded Java methods for a function with default parameter values. This allows Java callers (which don't support default parameters) to call the method with different parameter combinations.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_interop_quiz_4", "questionText": "How would a Java class access a top-level Kotlin extension function defined in a file named 'StringUtils.kt'?", "type": "MCQ", "options": ["As a static method on StringUtilsKt class", "As an instance method on String objects", "By importing kotlin.extensions.StringUtils", "Extension functions cannot be called from Java"], "correctAnswer": "As a static method on StringUtilsKt class", "explanation": "Top-level extension functions in Kotlin are compiled to static methods in a class named after the Kotlin file with 'Kt' appended. The receiver type becomes the first parameter of the static method. So extension functions in StringUtils.kt would be accessible as static methods of the StringUtilsKt class.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_interop_quiz_5", "questionText": "What happens when a Kotlin function throws an exception but doesn't declare it with @Throws when called from Java?", "type": "MCQ", "options": ["Java callers don't need to catch the exception", "Java code will get compiler errors", "The exception is automatically handled", "The code won't compile"], "correctAnswer": "Java callers don't need to catch the exception", "explanation": "Without the @Throws annotation, exceptions thrown by Kotlin functions are treated as unchecked exceptions when called from Java. This means Java callers aren't required to catch or declare them, even if they would normally be checked exceptions in Java. Use @Throws to make exceptions behave like Java's checked exceptions.", "difficulty": "HARD"}
  ]
}