{
  "topicId": "kotlin_extensions",
  "quizQuestions": [
    {"id": "kotlin_ext_quiz_1", "questionText": "Which of the following correctly defines an extension function for the String class?", "type": "MCQ", "options": ["fun String.countVowels(): Int { ... }", "extension fun String.countVowels(): Int { ... }", "fun countVowels(String): Int { ... }", "String.fun countVowels(): Int { ... }"], "correctAnswer": "fun String.countVowels(): Int { ... }", "explanation": "Extension functions are defined using the syntax 'fun ReceiverType.functionName(parameters): ReturnType'. The receiver type (String in this case) is placed before the function name with a dot.", "difficulty": "EASY"},
    
    {"id": "kotlin_ext_quiz_2", "questionText": "What is the main limitation of extension properties compared to regular properties?", "type": "MCQ", "options": ["They cannot have backing fields", "They cannot be accessed from Java code", "They cannot be mutable (var)", "They cannot be private"], "correctAnswer": "They cannot have backing fields", "explanation": "Extension properties cannot have backing fields because they don't actually add fields to the class they're extending. They can only be implemented using custom getters and setters that compute values or access existing properties.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_ext_quiz_3", "questionText": "Which Kotlin scope function returns the context object (this) and is primarily used for object configuration?", "type": "MCQ", "options": ["apply", "also", "let", "with"], "correctAnswer": "apply", "explanation": "apply executes a block of code on an object (using 'this' as the receiver) and returns the object itself. It's primarily used for object initialization and configuration, allowing for a fluent builder-like syntax.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_ext_quiz_4", "questionText": "In Kotlin DSLs, which feature is used to create function literals where the lambda parameter is implicitly available as 'this'?", "type": "MCQ", "options": ["Function literals with receiver", "Extension functions", "Infix notation", "Operator overloading"], "correctAnswer": "Function literals with receiver", "explanation": "Function literals with receiver (like Type.() -> Unit) are a key feature for building DSLs in Kotlin. They allow you to create lambdas where the receiver object is implicitly available as 'this', enabling a more natural, declarative syntax for domain-specific languages.", "difficulty": "HARD"},
    
    {"id": "kotlin_ext_quiz_5", "questionText": "What will be the output of the following code?\n\nclass Example {\n    fun printMessage() = println(\"Member\")\n}\n\nfun Example.printMessage() = println(\"Extension\")\n\nfun main() {\n    Example().printMessage()\n}", "type": "MCQ", "options": ["Member", "Extension", "Member\\nExtension", "Compilation error"], "correctAnswer": "Member", "explanation": "When there's a name conflict between a member function and an extension function, the member function always takes precedence. In this case, Example().printMessage() calls the member function, printing \"Member\".", "difficulty": "HARD"}
  ]
}