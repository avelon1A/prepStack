{
  "topicId": "kotlin_android",
  "quizQuestions": [
    {"id": "kotlin_android_quiz_1", "questionText": "Which Kotlin feature is most helpful in preventing NullPointerExceptions in Android apps?", "type": "MCQ", "options": ["Null safety system", "Extension functions", "Data classes", "Lambda expressions"], "correctAnswer": "Null safety system", "explanation": "Kotlin's null safety system with nullable types (?), non-null assertions (!!) and safe calls (?.) helps prevent NullPointerExceptions at compile time, which is a common crash source in Android applications written in Java.", "difficulty": "EASY"},
    
    {"id": "kotlin_android_quiz_2", "questionText": "When using ViewBinding in a Fragment, why should you set the binding reference to null in onDestroyView()?", "type": "MCQ", "options": ["To prevent memory leaks", "To improve performance", "To enable garbage collection of the view", "All of the above"], "correctAnswer": "All of the above", "explanation": "Setting the binding to null in onDestroyView() prevents memory leaks by breaking the reference to the Fragment's view hierarchy after it's destroyed but while the Fragment itself is still in memory. This allows views to be garbage collected and improves memory performance.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_android_quiz_3", "questionText": "Which of the following is NOT a component of Android KTX?", "type": "MCQ", "options": ["Dagger-KTX", "Core-KTX", "Fragment-KTX", "Navigation-KTX"], "correctAnswer": "Dagger-KTX", "explanation": "There is no official Dagger-KTX extension. Android KTX includes extensions for core Android framework, Jetpack libraries (like Fragment, Navigation, Lifecycle), and other common Android components, but Dagger, being a third-party dependency injection library, has its own Kotlin support but isn't part of the official KTX extensions.", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_android_quiz_4", "questionText": "What is the recommended way to collect a Flow in an Android UI component while respecting the lifecycle?", "type": "MCQ", "options": ["Using repeatOnLifecycle", "Using liveData builder", "Using GlobalScope", "Using withContext"], "correctAnswer": "Using repeatOnLifecycle", "explanation": "The repeatOnLifecycle API (from lifecycle-runtime-ktx library) is the recommended way to collect flows in UI components. It automatically cancels and restarts collection based on the specified lifecycle state, preventing processing during inactive states and avoiding memory leaks.", "difficulty": "HARD"},
    
    {"id": "kotlin_android_quiz_5", "questionText": "Which CoroutineScope is specifically designed for use in ViewModels?", "type": "MCQ", "options": ["viewModelScope", "lifecycleScope", "GlobalScope", "mainScope"], "correctAnswer": "viewModelScope", "explanation": "viewModelScope is a CoroutineScope tied to a ViewModel instance and automatically cancelled when the ViewModel is cleared. It's specifically designed for launching coroutines from ViewModels, ensuring they're properly cleaned up when the ViewModel is no longer used.", "difficulty": "EASY"}
  ]
}