{
  "topicId": "time_series_analysis",
  "questions": [
    {"id": "time_series_theory_1", "questionText": "What is time series analysis and what are its main components?", "type": "THEORY", "correctAnswer": "Time series analysis is the study of data points collected or recorded at specific time intervals. The main components of a time series include: 1) Trend - the long-term direction (increasing, decreasing, or stable), 2) Seasonality - repeating patterns at fixed intervals, 3) Cyclical components - patterns that occur but not at fixed frequencies, and 4) Irregular/residual components - random variations not explained by other components.", "explanation": "Decomposing a time series into these components helps understand underlying patterns, which is crucial for forecasting and anomaly detection.", "difficulty": "EASY"},
    
    {"id": "time_series_theory_2", "questionText": "What is stationarity in time series and why is it important?", "type": "THEORY", "correctAnswer": "A stationary time series has constant statistical properties over time, including constant mean, variance, and autocovariance. It's important because many time series models (like ARIMA) require stationarity as an assumption. Non-stationary series can lead to spurious relationships and unreliable forecasts.", "explanation": "Non-stationary data often needs to be transformed to achieve stationarity, typically through differencing, detrending, or mathematical transformations like logarithms.", "codeExample": "# Python example for checking and achieving stationarity\nimport pandas as pd\nimport numpy as np\nfrom statsmodels.tsa.stattools import adfuller\n\n# Augmented Dickey-Fuller test for stationarity\ndef check_stationarity(timeseries):\n    result = adfuller(timeseries)\n    print(f'ADF Statistic: {result[0]}')\n    print(f'p-value: {result[1]}')\n    if result[1] <= 0.05:\n        print(\"Stationary (reject null hypothesis)\")\n    else:\n        print(\"Non-stationary (fail to reject null hypothesis)\")\n        \n# Make a non-stationary series stationary through differencing\ndf['diff'] = df['value'].diff().dropna()\ncheck_stationarity(df['diff'])", "difficulty": "MEDIUM"},
    
    {"id": "time_series_theory_3", "questionText": "Explain the ARIMA model and its components.", "type": "THEORY", "correctAnswer": "ARIMA (AutoRegressive Integrated Moving Average) is a popular time series forecasting model with three components: 1) AR(p) - autoregressive terms where the variable is regressed on its own lagged values, 2) I(d) - integrated terms representing differencing to make the series stationary, and 3) MA(q) - moving average terms representing the error terms of the model as a linear combination of error terms from previous time steps.", "explanation": "ARIMA models are specified as ARIMA(p,d,q) where p is the order of autoregression, d is the degree of differencing, and q is the order of moving average. Selecting appropriate values for these parameters is a key aspect of model fitting.", "codeExample": "# Python example of ARIMA modeling\nfrom statsmodels.tsa.arima.model import ARIMA\nimport matplotlib.pyplot as plt\n\n# Fit ARIMA model\nmodel = ARIMA(df['value'], order=(1, 1, 1))  # ARIMA(p=1, d=1, q=1)\nmodel_fit = model.fit()\n\n# Summary\nprint(model_fit.summary())\n\n# Forecast\nforecast = model_fit.forecast(steps=10)  # Forecast next 10 periods\n\n# Plot original series and forecast\nplt.figure(figsize=(12, 6))\nplt.plot(df['value'], label='Original')\nplt.plot(pd.date_range(start=df.index[-1], periods=11, freq='D')[1:], \n         forecast, color='red', label='Forecast')\nplt.legend()\nplt.show()", "difficulty": "HARD"},
    
    {"id": "time_series_theory_4", "questionText": "What are the differences between time series forecasting and traditional regression approaches?", "type": "THEORY", "correctAnswer": "Time series forecasting differs from traditional regression in several ways: 1) Time series data has an inherent temporal ordering that must be preserved, 2) Observations are typically not independent but serially correlated, 3) Time series models often use past values of the target variable as predictors, 4) Stationarity of data is a key concern in time series but not in standard regression, and 5) Cross-validation must account for the temporal structure (e.g., time-based splits rather than random splits).", "explanation": "While regression aims to explain relationships between variables, time series forecasting specifically focuses on predicting future values based on patterns in historical data, often with time as the only independent variable.", "difficulty": "MEDIUM"},
    
    {"id": "time_series_theory_5", "questionText": "What are seasonality and trend, and how can they be identified and addressed in time series analysis?", "type": "THEORY", "correctAnswer": "Seasonality refers to regular, periodic patterns in the data (e.g., daily, weekly, monthly patterns). Trend refers to the long-term direction of the data. They can be identified through: 1) Visual inspection of time plots, 2) Autocorrelation and partial autocorrelation plots, 3) Seasonal decomposition techniques, and 4) Seasonal subseries plots. They can be addressed through: 1) Seasonal differencing, 2) Detrending, 3) Including seasonal terms in models (e.g., SARIMA), or 4) Using specialized models that account for seasonality.", "explanation": "Understanding and properly modeling seasonality and trend is crucial for accurate forecasting. Ignoring these components when present can lead to poor model performance.", "codeExample": "# Python example for decomposing time series\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nimport matplotlib.pyplot as plt\n\n# Decompose time series\ndecomposition = seasonal_decompose(\n    df['value'], \n    model='additive',  # or 'multiplicative'\n    period=12  # e.g., monthly seasonality in yearly data\n)\n\n# Plot decomposition\nfig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(12, 10))\ndecomposition.observed.plot(ax=ax1, title='Original')\ndecomposition.trend.plot(ax=ax2, title='Trend')\ndecomposition.seasonal.plot(ax=ax3, title='Seasonality')\ndecomposition.resid.plot(ax=ax4, title='Residuals')\nplt.tight_layout()\nplt.show()", "difficulty": "EASY"}
  ]
}