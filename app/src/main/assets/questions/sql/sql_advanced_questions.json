{
  "topicId": "sql_advanced",
  "questions": [
    {"id": "sql_adv_theory_1", "questionText": "What are Common Table Expressions (CTEs) in SQL?", "type": "THEORY", "correctAnswer": "Common Table Expressions (CTEs) are named temporary result sets defined within the execution scope of a single SQL statement. They are created using the WITH clause and can be referenced multiple times in the same query.", "explanation": "CTEs improve query readability and maintainability by breaking down complex queries into simpler, modular components. They can be non-recursive or recursive, with recursive CTEs being particularly useful for hierarchical data.", "codeExample": "-- Simple CTE\nWITH EmployeeSalaries AS (\n    SELECT department_id, AVG(salary) as avg_salary\n    FROM employees\n    GROUP BY department_id\n)\nSELECT d.name, es.avg_salary\nFROM departments d\nJOIN EmployeeSalaries es ON d.id = es.department_id;\n\n-- Recursive CTE for organizational hierarchy\nWITH RECURSIVE EmployeeHierarchy AS (\n    SELECT id, name, manager_id, 0 as level\n    FROM employees\n    WHERE manager_id IS NULL\n    UNION ALL\n    SELECT e.id, e.name, e.manager_id, eh.level + 1\n    FROM employees e\n    JOIN EmployeeHierarchy eh ON e.manager_id = eh.id\n)\nSELECT id, name, level FROM EmployeeHierarchy;", "difficulty": "HARD"},
    
    {"id": "sql_adv_theory_2", "questionText": "What are window functions in SQL and how do they differ from aggregate functions?", "type": "THEORY", "correctAnswer": "Window functions perform calculations across a set of table rows related to the current row, unlike aggregate functions which group rows into a single output row. Window functions maintain the individual rows while adding calculated values based on a specified 'window' of rows.", "explanation": "Window functions are powerful for analytical queries, allowing calculations like running totals, percentiles, row numbers, and comparisons to other rows without collapsing the result set through grouping.", "codeExample": "-- Simple window function\nSELECT name, department_id, salary,\n       AVG(salary) OVER (PARTITION BY department_id) as dept_avg_salary,\n       salary - AVG(salary) OVER (PARTITION BY department_id) as diff_from_avg\nFROM employees;\n\n-- Row numbering within partitions\nSELECT name, department_id, salary,\n       ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank\nFROM employees;\n\n-- Running total\nSELECT name, hire_date, salary,\n       SUM(salary) OVER (ORDER BY hire_date) as running_total_salary\nFROM employees;", "difficulty": "HARD"},
    
    {"id": "sql_adv_theory_3", "questionText": "What is a materialized view and how does it differ from a regular view?", "type": "THEORY", "correctAnswer": "A materialized view stores the results of a query physically, unlike a regular view which executes its defining query each time it's accessed. Materialized views need to be refreshed to stay updated with the base tables, but provide faster access for complex or frequently-used queries.", "explanation": "Materialized views are a performance optimization technique, trading storage space and potential data staleness for improved query performance. They're particularly useful for data warehousing, reporting, and caching complex aggregations.", "codeExample": "-- PostgreSQL materialized view\nCREATE MATERIALIZED VIEW monthly_sales AS\nSELECT product_id, date_trunc('month', sale_date) as month, SUM(amount) as total_sales\nFROM sales\nGROUP BY product_id, date_trunc('month', sale_date);\n\n-- Refresh the materialized view\nREFRESH MATERIALIZED VIEW monthly_sales;", "difficulty": "MEDIUM"},
    
    {"id": "sql_adv_theory_4", "questionText": "What are SQL stored procedures and what are their advantages?", "type": "THEORY", "correctAnswer": "Stored procedures are precompiled SQL statements stored in the database that can be executed repeatedly. They can accept parameters, perform complex operations, and return results. Advantages include improved performance, reduced network traffic, enhanced security, and code reuse.", "explanation": "Stored procedures are a key database programming feature for encapsulating business logic in the database, centralizing complex operations, and implementing security measures by controlling access to underlying tables.", "codeExample": "-- SQL Server stored procedure\nCREATE PROCEDURE transfer_funds\n    @from_account INT,\n    @to_account INT,\n    @amount DECIMAL(10,2),\n    @success BIT OUTPUT\nAS\nBEGIN\n    BEGIN TRANSACTION;\n    \n    BEGIN TRY\n        -- Deduct from source account\n        UPDATE accounts SET balance = balance - @amount \n        WHERE account_id = @from_account AND balance >= @amount;\n        \n        IF @@ROWCOUNT = 0\n        BEGIN\n            SET @success = 0;\n            ROLLBACK;\n            RETURN;\n        END\n        \n        -- Add to destination account\n        UPDATE accounts SET balance = balance + @amount \n        WHERE account_id = @to_account;\n        \n        COMMIT;\n        SET @success = 1;\n    END TRY\n    BEGIN CATCH\n        ROLLBACK;\n        SET @success = 0;\n    END CATCH\nEND;", "difficulty": "MEDIUM"},
    
    {"id": "sql_adv_theory_5", "questionText": "What is database partitioning and what are its benefits?", "type": "THEORY", "correctAnswer": "Database partitioning divides large tables into smaller, more manageable pieces (partitions) based on defined criteria like ranges, lists, or hash values. Benefits include improved query performance, easier maintenance, enhanced availability, and more efficient backup and recovery operations.", "explanation": "Partitioning is a scalability strategy that helps manage very large tables by dividing them into smaller parts that can be managed and accessed independently. It's especially useful for time-series data or data with clear logical divisions.", "codeExample": "-- PostgreSQL range partitioning example\nCREATE TABLE sales (\n    id SERIAL,\n    sale_date DATE NOT NULL,\n    amount DECIMAL(10,2),\n    customer_id INT\n) PARTITION BY RANGE (sale_date);\n\n-- Create partitions\nCREATE TABLE sales_2020 PARTITION OF sales\n    FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');\n\nCREATE TABLE sales_2021 PARTITION OF sales\n    FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');\n\nCREATE TABLE sales_2022 PARTITION OF sales\n    FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');", "difficulty": "HARD"}
  ]
}