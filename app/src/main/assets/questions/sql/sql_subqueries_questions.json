{
  "topicId": "sql_subqueries",
  "questions": [
    {"id": "sql_subq_theory_1", "questionText": "What is a SQL subquery?", "type": "THEORY", "correctAnswer": "A subquery is a query nested inside another query. It can appear in the SELECT, FROM, WHERE, or HAVING clauses of the main query.", "explanation": "Subqueries allow you to use the results of one query as input for another query, enabling complex data operations that might be difficult to express with joins alone.", "difficulty": "EASY"},
    
    {"id": "sql_subq_theory_2", "questionText": "What is the difference between a correlated and non-correlated subquery?", "type": "THEORY", "correctAnswer": "A correlated subquery references columns from the outer query and is evaluated once for each row processed by the outer query. A non-correlated subquery is independent and executed once for the entire outer query.", "explanation": "Correlated subqueries are more complex and potentially less efficient because they run multiple times. Non-correlated subqueries are generally more efficient because they execute only once.", "codeExample": "-- Non-correlated subquery\nSELECT name\nFROM employees\nWHERE department_id IN (SELECT id FROM departments WHERE location = 'New York');\n\n-- Correlated subquery\nSELECT name\nFROM employees e\nWHERE salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);", "difficulty": "HARD"},
    
    {"id": "sql_subq_theory_3", "questionText": "Explain the use of subqueries in the FROM clause.", "type": "THEORY", "correctAnswer": "A subquery in the FROM clause, also known as a derived table or inline view, creates a temporary result set that can be queried like a regular table. It must have an alias and can be joined with other tables.", "explanation": "FROM clause subqueries are useful for working with intermediate results or for simplifying complex queries by breaking them into more manageable parts.", "codeExample": "SELECT d.department_name, avg_sal.average_salary\nFROM departments d\nJOIN (\n    SELECT department_id, AVG(salary) as average_salary\n    FROM employees\n    GROUP BY department_id\n) avg_sal ON d.department_id = avg_sal.department_id;", "difficulty": "MEDIUM"},
    
    {"id": "sql_subq_theory_4", "questionText": "What are scalar subqueries and how are they used?", "type": "THEORY", "correctAnswer": "A scalar subquery returns exactly one column and one row (a single value). It can be used anywhere an expression or single value is expected, such as in SELECT, WHERE, or HAVING clauses.", "explanation": "Scalar subqueries are versatile and can be used for comparisons, calculations, or as column values in the result set.", "codeExample": "-- Scalar subquery in SELECT\nSELECT name, salary, \n       (SELECT AVG(salary) FROM employees) as company_avg_salary\nFROM employees;\n\n-- Scalar subquery in WHERE\nSELECT name\nFROM employees\nWHERE salary > (SELECT AVG(salary) FROM employees);", "difficulty": "MEDIUM"},
    
    {"id": "sql_subq_theory_5", "questionText": "How do EXISTS and NOT EXISTS work with subqueries?", "type": "THEORY", "correctAnswer": "EXISTS returns true if the subquery returns at least one row, otherwise false. NOT EXISTS returns true if the subquery returns no rows. They are typically used with correlated subqueries to check for the presence or absence of related records.", "explanation": "EXISTS is often more efficient than IN for large datasets because it can stop searching once it finds a single matching row, rather than having to process the entire subquery result.", "codeExample": "-- Find departments with at least one employee\nSELECT name\nFROM departments d\nWHERE EXISTS (\n    SELECT 1 FROM employees\n    WHERE department_id = d.id\n);\n\n-- Find departments with no employees\nSELECT name\nFROM departments d\nWHERE NOT EXISTS (\n    SELECT 1 FROM employees\n    WHERE department_id = d.id\n);", "difficulty": "HARD"}
  ]
}