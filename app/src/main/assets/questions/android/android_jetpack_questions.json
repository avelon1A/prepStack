{
  "topicId": "android_jetpack",
  "questions": [
    {"id": "compose_theory_1", "questionText": "What is Jetpack Compose?", "type": "THEORY", "correctAnswer": "Jetpack Compose is Android's modern toolkit for building native UI using a declarative approach with Kotlin.", "explanation": "Compose simplifies and accelerates UI development by allowing you to describe your UI in composable functions.", "codeExample": "@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "compose_theory_2", "questionText": "What is a Composable function?", "type": "THEORY", "correctAnswer": "A Composable function is a function annotated with @Composable that describes a piece of UI and can emit UI elements.", "explanation": "Composable functions are the building blocks of Compose UI. They can call other composable functions and can accept parameters to customize their behavior.", "codeExample": "@Composable\nfun MyButton(text: String, onClick: () -> Unit) {\n    Button(onClick = onClick) {\n        Text(text)\n    }\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "compose_theory_3", "questionText": "What is State in Jetpack Compose?", "type": "THEORY", "correctAnswer": "State in Compose is any value that can change over time and affects the UI. When state changes, Compose automatically recomposes the affected composables.", "explanation": "State is the single source of truth for your UI. Compose tracks state changes and efficiently updates only the composables that depend on that state.", "codeExample": "@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n    Button(onClick = { count++ }) {\n        Text(\"Count: $count\")\n    }\n}", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "compose_theory_4", "questionText": "What is the difference between remember and rememberSaveable?", "type": "THEORY", "correctAnswer": "remember keeps state across recompositions but loses it on configuration changes. rememberSaveable keeps state across recompositions and survives configuration changes.", "explanation": "Use remember for transient state that doesn't need to survive configuration changes. Use rememberSaveable for state that should persist across screen rotations and process death.", "codeExample": "// Lost on rotation\nvar count by remember { mutableStateOf(0) }\n\n// Survives rotation\nvar count by rememberSaveable { mutableStateOf(0) }", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "compose_theory_5", "questionText": "What is LaunchedEffect in Compose?", "type": "THEORY", "correctAnswer": "LaunchedEffect is a composable that launches a coroutine tied to the scope of the composition. It runs when the composition enters and is cancelled when it leaves.", "explanation": "LaunchedEffect is useful for running side effects like making network calls, showing animations, or triggering one-time events when a composable enters the composition.", "codeExample": "LaunchedEffect(key1) {\n    // Run coroutine\n    delay(1000)\n    // Do something\n}", "imageUrl": "", "difficulty": "HARD"}
  ]
}
