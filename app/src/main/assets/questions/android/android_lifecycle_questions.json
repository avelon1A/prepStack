{
  "topicId": "android_lifecycle",
  "questions": [
    {"id": "lifecycle_theory_1", "questionText": "What is the difference between onStart() and onResume()?", "type": "THEORY", "correctAnswer": "onStart() is called when the activity becomes visible to the user. onResume() is called when the activity starts interacting with the user.", "explanation": "onStart() indicates the activity is visible but may not be in the foreground. onResume() indicates the activity is in the foreground and ready for user interaction.", "codeExample": "override fun onStart() {\n    super.onStart()\n    // Activity is visible\n}\n\nooverride fun onResume() {\n    super.onResume()\n    // Activity is in foreground and ready for interaction\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "lifecycle_theory_2", "questionText": "What is the purpose of onSaveInstanceState()?", "type": "THEORY", "correctAnswer": "onSaveInstanceState() is called to save transient state data before an activity may be killed by the system, allowing restoration in onCreate() or onRestoreInstanceState().", "explanation": "Use this method to save data that should persist across configuration changes or when the system kills the process to reclaim memory.", "codeExample": "override fun onSaveInstanceState(outState: Bundle) {\n    super.onSaveInstanceState(outState)\n    outState.putString(\"key\", value)\n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    savedInstanceState?.getString(\"key\")?.let { value = it }\n}", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "lifecycle_theory_3", "questionText": "What is the difference between onPause() and onStop()?", "type": "THEORY", "correctAnswer": "onPause() is called when the activity is partially obscured by another activity. onStop() is called when the activity is no longer visible to the user.", "explanation": "onPause() is used for tasks that should happen when the activity is still visible but not in focus. onStop() is for cleanup when the activity is completely hidden.", "codeExample": "override fun onPause() {\n    super.onPause()\n    // Stop animations, save unsaved data\n}\n\noverride fun onStop() {\n    super.onStop()\n    // Release resources, unregister listeners\n}", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "lifecycle_theory_4", "questionText": "What is a ViewModel and how does it relate to lifecycle?", "type": "THEORY", "correctAnswer": "ViewModel is a lifecycle-aware component designed to store and manage UI-related data, surviving configuration changes like screen rotations.", "explanation": "ViewModel is cleared when the associated lifecycle scope (like an Activity or Fragment) is permanently destroyed, not during configuration changes.", "codeExample": "class MyViewModel : ViewModel() {\n    private val _data = MutableLiveData<String>()\n    val data: LiveData<String> = _data\n}\n\n// In Activity\nval viewModel = ViewModelProvider(this)[MyViewModel::class.java]", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "lifecycle_theory_5", "questionText": "What is the purpose of LifecycleObserver?", "type": "THEORY", "correctAnswer": "LifecycleObserver is an interface that allows classes to monitor lifecycle events without extending from Android lifecycle components like Activity or Fragment.", "explanation": "You can annotate methods with @OnLifecycleEvent to respond to lifecycle changes, making it easy to create lifecycle-aware components.", "codeExample": "class MyObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume() {\n        // Handle resume event\n    }\n}\n\n// In Activity\nlifecycle.addObserver(MyObserver())", "imageUrl": "", "difficulty": "HARD"}
  ]
}