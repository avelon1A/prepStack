{
  "topicId": "android_room",
  "questions": [
    {"id": "room_theory_1", "questionText": "What is Room in Android?", "type": "THEORY", "correctAnswer": "Room is a persistence library that provides an abstraction layer over SQLite, allowing for more robust database access while harnessing the full power of SQLite.", "explanation": "Room provides type safety, compile-time query verification, and easier code for working with SQLite.", "codeExample": "@Entity\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String\n)\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAll(): List<User>\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "room_theory_2", "questionText": "What are the three main components of Room?", "type": "THEORY", "correctAnswer": "Entity (data model), DAO (Data Access Object), and Database (main database class).", "explanation": "Entity: data class mapped to a table. DAO: interface for accessing the data. Database: holds the database and serves as main access point.", "codeExample": "// 1. Entity\n@Entity\ndata class User(@PrimaryKey val id: Int)\n// 2. DAO\n@Dao\ninterface UserDao { @Query(\"SELECT * FROM user\") fun getAll(): List<User> }\n// 3. Database\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "room_theory_3", "questionText": "What is the purpose of @Entity annotation?", "type": "THEORY", "correctAnswer": "@Entity marks a class as a table in a Room database, with each field representing a column in the table.", "explanation": "Room uses @Entity to generate table schemas. You can customize names and set primary keys and indices.", "codeExample": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    @ColumnInfo(name = \"user_name\")\n    val name: String\n)", "imageUrl": "", "difficulty": "EASY"},
    {"id": "room_theory_4", "questionText": "What is the difference between @Query, @Insert, @Update, and @Delete?", "type": "THEORY", "correctAnswer": "@Query for custom SQL. @Insert for adding records. @Update for modifying, @Delete for removing.", "explanation": "Each annotation determines what database operation is performed in a DAO method.", "codeExample": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user WHERE id = :id\")\n    fun getUserById(id: Int): User\n    @Insert\n    fun insert(user: User)\n    @Update\n    fun update(user: User)\n    @Delete\n    fun delete(user: User)\n}", "imageUrl": "", "difficulty": "MEDIUM"},
    {"id": "room_theory_5", "questionText": "What is LiveData and how does it work with Room?", "type": "THEORY", "correctAnswer": "LiveData is an observable data holder that is lifecycle-aware. When used with Room, it automatically updates the UI when database data changes.", "explanation": "When a DAO returns LiveData, Room notifies observers when data changes, keeping UI in sync.", "codeExample": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAllUsers(): LiveData<List<User>>\n}\n// In ViewModel\nval users = userDao.getAllUsers()\n// In Activity\nusers.observe(this) { userList ->\n    // Update UI with new data\n}", "imageUrl": "", "difficulty": "MEDIUM"}
  ]
}
