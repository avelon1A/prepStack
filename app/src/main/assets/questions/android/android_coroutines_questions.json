{
  "topicId": "android_coroutines",
  "questions": [
    {"id": "coroutines_theory_1", "questionText": "What are Coroutines in Kotlin?", "type": "THEORY", "correctAnswer": "Coroutines are a way to write asynchronous, non-blocking code that looks synchronous, making it easier to handle long-running tasks like network operations.", "explanation": "Coroutines provide a sequential style for async code, avoiding callback hell.", "codeExample": "// Synchronous-looking async code\nsuspend fun fetchData(): String {\n    return withContext(Dispatchers.IO) {\n        // Network operation\n        \"Data\"\n    }\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "coroutines_theory_2", "questionText": "What is the 'suspend' keyword?", "type": "THEORY", "correctAnswer": "The 'suspend' keyword marks a function as capable of being paused and resumed without blocking the thread, allowing it to be called from coroutines.", "explanation": "Suspend functions are called either from other suspend functions or coroutine scopes.", "codeExample": "suspend fun fetchData(): String {\n    delay(1000) // Non-blocking delay\n    return \"Data\"\n}\n// Can only be called from coroutine\nGlobalScope.launch {\n    val data = fetchData()\n}", "imageUrl": "", "difficulty": "EASY"},
    {"id": "coroutines_theory_3", "questionText": "What are the different Coroutine Dispatchers?", "type": "THEORY", "correctAnswer": "Dispatchers.Main (UI thread), Dispatchers.IO (I/O), Dispatchers.Default (CPU-bound), Dispatchers.Unconfined.", "explanation": "Dispatchers control which thread(s) coroutines run on.", "codeExample": "// Main - UI ops\nwithContext(Dispatchers.Main) { ... }\n// IO - network/db ops\nwithContext(Dispatchers.IO) { ... }\n// Default - CPU\nwithContext(Dispatchers.Default) { ... }", "imageUrl": "", "difficulty": "MEDIUM"}
  ]
}
