{
  "topicId": "kotlin_android",
  "questions": [
    {"id": "kotlin_android_theory_1", "questionText": "How does Kotlin improve Android development compared to Java?", "type": "THEORY", "correctAnswer": "Kotlin improves Android development through: 1) Null safety with nullable types and safe calls, reducing NullPointerExceptions, 2) Concise syntax with data classes, extension functions, and higher-order functions, 3) Coroutines for asynchronous programming, 4) Better functional programming support, 5) Built-in delegation and property delegation, 6) Smart casts, 7) First-class support from Google with Android KTX extensions, and 8) 100% Java interoperability.", "explanation": "These features lead to more reliable, readable, and maintainable Android apps with less boilerplate code. Kotlin is officially supported by Google for Android development since 2017.", "difficulty": "EASY"},
    
    {"id": "kotlin_android_theory_2", "questionText": "What are Android KTX extensions and how do they improve Android development?", "type": "THEORY", "correctAnswer": "Android KTX (Kotlin Extensions) is a set of Kotlin extensions that optimize the Kotlin programming experience for Android development. These extensions leverage Kotlin's language features like extension functions, lambdas, and named parameters to make Android APIs more concise, idiomatic, and pleasant to use. KTX libraries exist for core Android, fragments, lifecycle components, navigation, Room, WorkManager, and other Jetpack libraries.", "explanation": "KTX doesn't add new functionality but makes existing APIs more accessible and reduces boilerplate code. It's structured as a collection of modules that can be included individually based on which APIs you're using.", "codeExample": "// Without KTX\nview.setOnClickListener(object : View.OnClickListener {\n    override fun onClick(view: View) {\n        // Handle click\n    }\n})\n\n// With KTX\nview.setOnClickListener { /* Handle click */ }\n\n// Without KTX\nval sharedPrefs = context.getSharedPreferences(\"prefs\", Context.MODE_PRIVATE)\nsharedPrefs.edit().putString(\"key\", \"value\").apply()\n\n// With KTX\ncontext.getSharedPreferences(\"prefs\", Context.MODE_PRIVATE).edit {\n    putString(\"key\", \"value\")\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_android_theory_3", "questionText": "How do Kotlin's coroutines improve asynchronous programming in Android?", "type": "THEORY", "correctAnswer": "Kotlin coroutines improve Android async programming by: 1) Providing a sequential programming model that avoids callback hell, 2) Offering built-in cancellation support aligned with Android lifecycle, 3) Handling exceptions naturally with try-catch blocks, 4) Reducing thread usage with suspension instead of blocking, 5) Simplifying concurrent operations like parallel network requests, 6) Working seamlessly with Jetpack libraries through lifecycle-aware coroutine scopes, and 7) Reducing memory leaks through structured concurrency.", "explanation": "Coroutines have become the recommended approach for asynchronous programming in Android, replacing AsyncTask (now deprecated), RxJava (in many cases), and other callback-based approaches.", "codeExample": "// ViewModel with coroutines\nclass MyViewModel : ViewModel() {\n    private val _data = MutableLiveData<Result<Data>>()\n    val data: LiveData<Result<Data>> = _data\n\n    fun loadData() {\n        viewModelScope.launch {\n            try {\n                _data.value = Result.Loading\n                // Suspension point - thread not blocked\n                val result = repository.fetchData()\n                _data.value = Result.Success(result)\n            } catch (e: Exception) {\n                _data.value = Result.Error(e)\n            }\n        }\n    }\n}\n\n// Activity/Fragment\nviewModel.data.observe(viewLifecycleOwner) { result ->\n    when (result) {\n        is Result.Loading -> showLoading()\n        is Result.Success -> showData(result.data)\n        is Result.Error -> showError(result.exception)\n    }\n}", "difficulty": "HARD"},
    
    {"id": "kotlin_android_theory_4", "questionText": "What is the ViewBinding feature in Android and how does it work with Kotlin?", "type": "THEORY", "correctAnswer": "ViewBinding is an Android Jetpack feature that generates binding classes for XML layouts, providing type-safe access to views. In Kotlin, it eliminates the need for findViewById() or synthetic properties (now deprecated). Each binding class contains direct references to all views with IDs in the layout. ViewBinding is enabled by adding 'viewBinding = true' to the module's build.gradle file. It offers compile-time safety, null safety, and type safety advantages.", "explanation": "ViewBinding strikes a balance between the simplicity of synthetic view properties (kotlinx.android.synthetic, now deprecated) and the full feature set of Data Binding, providing safe view access without the annotation processing overhead of Data Binding.", "codeExample": "// Enable in build.gradle\nandroid {\n    viewBinding = true\n}\n\n// Activity usage\nclass MainActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityMainBinding\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        \n        binding.textView.text = \"Hello World\"\n        binding.button.setOnClickListener { showMessage() }\n    }\n}\n\n// Fragment usage\nclass MainFragment : Fragment() {\n    private var _binding: FragmentMainBinding? = null\n    private val binding get() = _binding!!\n    \n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {\n        _binding = FragmentMainBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n    \n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null // Prevent memory leaks\n    }\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_android_theory_5", "questionText": "What is Flow in Kotlin and how is it used in Android development?", "type": "THEORY", "correctAnswer": "Flow is a Kotlin coroutine-based API for asynchronous stream processing of sequential data. In Android, Flow is used for: 1) Reactive programming with cold streams, 2) Handling continuous data updates like sensor readings or database changes, 3) Processing data transformations with operators like map, filter, etc., 4) Converting callback-based APIs to coroutine-based, 5) Replacing LiveData in some scenarios, and 6) Building clean architecture with reactive data layers. Flow integrates with coroutines for structured concurrency and cancellation.", "explanation": "Flow is part of the kotlinx.coroutines library and provides a simpler alternative to RxJava for many use cases. Unlike LiveData, Flow is not lifecycle-aware by default but can be made lifecycle-aware using the lifecycle-runtime-ktx library.", "codeExample": "// Repository that returns Flow\nclass UserRepository(private val userDao: UserDao) {\n    fun getUsers(): Flow<List<User>> = userDao.getAll()\n    \n    suspend fun refreshUsers() {\n        val users = api.fetchUsers()\n        userDao.insertAll(users)\n        // Flow collectors automatically get the updated data\n    }\n}\n\n// ViewModel with Flow\nclass UserViewModel(private val repository: UserRepository) : ViewModel() {\n    private val _sortOrder = MutableStateFlow(SortOrder.NAME)\n    \n    val users = _sortOrder.flatMapLatest { sortOrder ->\n        repository.getUsers().map { users ->\n            when (sortOrder) {\n                SortOrder.NAME -> users.sortedBy { it.name }\n                SortOrder.AGE -> users.sortedBy { it.age }\n            }\n        }\n    }.stateIn(\n        viewModelScope,\n        SharingStarted.WhileSubscribed(5000),\n        emptyList()\n    )\n    \n    fun setSortOrder(order: SortOrder) {\n        _sortOrder.value = order\n    }\n}\n\n// Fragment collecting Flow\nviewLifecycleOwner.lifecycleScope.launch {\n    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {\n        viewModel.users.collect { users ->\n            adapter.submitList(users)\n        }\n    }\n}", "difficulty": "HARD"}
  ]
}