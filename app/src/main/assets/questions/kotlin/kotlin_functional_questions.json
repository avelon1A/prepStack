{
  "topicId": "kotlin_functional",
  "questions": [
    {"id": "kotlin_functional_theory_1", "questionText": "What are higher-order functions and how are they used in Kotlin?", "type": "THEORY", "correctAnswer": "Higher-order functions are functions that can take functions as parameters or return functions. In Kotlin, they're used for creating reusable abstractions, implementing callbacks and event handlers, working with collections (map, filter, reduce), creating DSLs, and implementing design patterns like decorators. They're a fundamental part of Kotlin's functional programming support.", "explanation": "Higher-order functions enable powerful abstraction patterns and reduce boilerplate code. They allow for more modular and compositional code design.", "codeExample": "// Function that takes another function as parameter\nfun <T, R> Collection<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n    }\n    return accumulator\n}\n\n// Usage\nval sum = listOf(1, 2, 3).fold(0) { acc, i -> acc + i }", "difficulty": "EASY"},
    
    {"id": "kotlin_functional_theory_2", "questionText": "What are lambdas and closures in Kotlin? How do they differ?", "type": "THEORY", "correctAnswer": "Lambdas in Kotlin are anonymous functions that can be passed around as values. They have a concise syntax with implicit parameters and type inference. Closures are lambdas that capture variables from their surrounding scope. In Kotlin, all lambdas are closures - they can access and modify variables defined outside their body.", "explanation": "Lambdas simplify code by providing a more readable syntax for small function implementations. Closures are powerful because they maintain references to their outer scope variables, allowing for stateful functional programming.", "codeExample": "// Lambda expression\nval sum = { x: Int, y: Int -> x + y }\nprintln(sum(1, 2)) // Prints 3\n\n// Lambda as a closure\nfun createCounter(): () -> Int {\n    var count = 0\n    return { count++ } // This lambda captures the count variable\n}\n\nval counter = createCounter()\nprintln(counter()) // 0\nprintln(counter()) // 1", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_functional_theory_3", "questionText": "Explain Kotlin's collection transformation functions (map, filter, flatMap, etc.) and their use cases.", "type": "THEORY", "correctAnswer": "Kotlin provides a rich set of collection transformation functions: map transforms elements, filter selects elements based on predicates, flatMap transforms and flattens nested collections, reduce and fold aggregate elements, groupBy categorizes elements, take/drop select portions of collections, and zip combines collections. These functions process collections functionally, returning new collections rather than modifying the originals.", "explanation": "These functions make collection processing code more concise, readable, and less error-prone than manual loops. They also enable chaining operations into processing pipelines.", "codeExample": "val numbers = listOf(1, 2, 3, 4, 5, 6)\n\n// Map: transform each element\nval squared = numbers.map { it * it } // [1, 4, 9, 16, 25, 36]\n\n// Filter: select elements matching a predicate\nval even = numbers.filter { it % 2 == 0 } // [2, 4, 6]\n\n// FlatMap: transform and flatten\nval nested = listOf(listOf(1, 2), listOf(3, 4))\nval flattened = nested.flatMap { it } // [1, 2, 3, 4]\n\n// Combined operations\nval sumOfEvenSquares = numbers\n    .filter { it % 2 == 0 }\n    .map { it * it }\n    .sum() // 4 + 16 + 36 = 56", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_functional_theory_4", "questionText": "What are sequence operations in Kotlin and how do they differ from collection operations?", "type": "THEORY", "correctAnswer": "Sequences in Kotlin represent lazily evaluated collections, where operations are only performed when the result is needed. Unlike collections, which execute operations eagerly and create intermediate collections for each step, sequences process elements one by one through the entire chain of operations, which can significantly improve performance for large collections or multiple operations. Sequences use intermediate and terminal operations similar to Java Streams.", "explanation": "The main difference is evaluation strategy: eager (collections) vs lazy (sequences). Eager evaluation is simpler and works well for small collections, while lazy evaluation is more efficient for large datasets and complex operation chains.", "codeExample": "// Eager evaluation (collections)\nval result = listOf(1, 2, 3, 4, 5)\n    .filter { println(\"Filter $it\"); it % 2 == 0 }\n    .map { println(\"Map $it\"); it * it }\n    .first()\n// Prints: Filter 1, Filter 2, Filter 3, Filter 4, Filter 5, Map 2, Map 4\n\n// Lazy evaluation (sequences)\nval result = listOf(1, 2, 3, 4, 5).asSequence()\n    .filter { println(\"Filter $it\"); it % 2 == 0 }\n    .map { println(\"Map $it\"); it * it }\n    .first()\n// Prints: Filter 1, Filter 2, Map 2", "difficulty": "HARD"},
    
    {"id": "kotlin_functional_theory_5", "questionText": "What are inline functions in Kotlin and how do they relate to higher-order functions?", "type": "THEORY", "correctAnswer": "Inline functions are functions whose body is substituted (inlined) at the call site, replacing the function call. When applied to higher-order functions, not only the function itself but also lambda arguments are inlined, eliminating the runtime overhead of lambda object creation and virtual calls. Inline functions also enable non-local returns in lambdas and access to reified type parameters.", "explanation": "Inlining is primarily a performance optimization, particularly for small, frequently called functions that take lambdas. The stdlib collection functions like map, filter, etc., are inline for this reason.", "codeExample": "// Without inline, a lambda is compiled to an anonymous class\nfun regularFunction(action: () -> Unit) {\n    action()\n}\n\n// With inline, lambda code is copied to the call site\ninline fun inlinedFunction(action: () -> Unit) {\n    action()\n}\n\n// Non-local return (only possible in inline functions)\ninline fun forEach(list: List<String>, action: (String) -> Unit) {\n    for (item in list) {\n        action(item) // The lambda can return from the caller function\n    }\n}\n\nfun processItems(items: List<String>) {\n    forEach(items) { item ->\n        if (item.isEmpty()) return // Returns from processItems\n        println(item)\n    }\n}", "difficulty": "HARD"}
  ]
}