{
  "topicId": "kotlin_coroutines",
  "questions": [
    {"id": "kotlin_coroutines_theory_1", "questionText": "What are Kotlin coroutines and how do they differ from threads?", "type": "THEORY", "correctAnswer": "Kotlin coroutines are a lightweight concurrency framework that allows writing asynchronous code in a sequential style. Unlike threads, coroutines are not tied to a specific OS thread and can be suspended and resumed without blocking the thread. They provide structured concurrency, built-in cancellation, and significantly lower overhead compared to threads.", "explanation": "Threads are relatively expensive resources managed by the OS, while coroutines are managed by the application and can scale to hundreds of thousands of concurrent operations. Coroutines simplify asynchronous programming without the complexity of callbacks or reactive streams.", "difficulty": "EASY"},
    
    {"id": "kotlin_coroutines_theory_2", "questionText": "Explain coroutine contexts and dispatchers in Kotlin.", "type": "THEORY", "correctAnswer": "CoroutineContext is a set of elements that define the behavior of a coroutine, including its dispatcher, job, name, and exception handler. Dispatchers determine which thread or threads the coroutine runs on. Common dispatchers include Dispatchers.Main (UI thread), Dispatchers.IO (optimized for IO operations), Dispatchers.Default (CPU-intensive tasks), and Dispatchers.Unconfined (runs in the current thread until first suspension).", "explanation": "Contexts can be combined and inherited, allowing fine-grained control of coroutine execution. The context is immutable, but new contexts can be created by adding or removing elements.", "codeExample": "// Launch with a specific dispatcher\nlaunch(Dispatchers.IO) {\n    // IO operations\n}\n\n// Combined context\nlaunch(Dispatchers.Default + CoroutineName(\"Calculation\")) {\n    // CPU-intensive work\n}\n\n// Context inheritance\ncoroutineScope {\n    // Inherits context but uses a new Job\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_coroutines_theory_3", "questionText": "What is structured concurrency in Kotlin coroutines?", "type": "THEORY", "correctAnswer": "Structured concurrency is a design principle that ensures coroutines are scoped and structured in a parent-child hierarchy. It guarantees that: 1) Parent coroutines wait for all children to complete, 2) Cancellation is propagated through the hierarchy, 3) Errors are properly propagated upward, and 4) Resources are properly cleaned up. Structured concurrency is implemented through coroutine builders like coroutineScope and supervisorScope.", "explanation": "This approach prevents common concurrency problems like leaking resources, unhandled exceptions, or forgotten background work. It makes concurrent code more predictable and manageable.", "codeExample": "suspend fun loadUserData(): UserData = coroutineScope {\n    // Parent coroutine waits for all children\n    val profile = async { api.loadProfile() }\n    val friends = async { api.loadFriends() }\n    val photos = async { api.loadPhotos() }\n    \n    // If any child fails, the entire scope fails\n    // All coroutines are cancelled upon error\n    UserData(profile.await(), friends.await(), photos.await())\n}", "difficulty": "HARD"},
    
    {"id": "kotlin_coroutines_theory_4", "questionText": "What is the difference between launch, async, and runBlocking coroutine builders?", "type": "THEORY", "correctAnswer": "launch: Creates a coroutine that doesn't return a result, returns a Job for cancellation. Used for fire-and-forget operations.\nasync: Creates a coroutine that returns a Deferred<T> (promise), which can be awaited for a result. Used when you need a value back.\nrunBlocking: Bridges between blocking and suspending worlds by blocking the current thread until all coroutines complete. Primarily used in main functions and tests.", "explanation": "launch and async are non-blocking and intended for regular coroutine usage. runBlocking is blocking and should be used sparingly, mostly at application entry points.", "codeExample": "// launch: Fire and forget\nval job = launch {\n    // Async work, no result needed\n}\n\n// async: Get a future result\nval deferred = async {\n    // Return a computation result\n    calculateValue()\n}\nval result = deferred.await()\n\n// runBlocking: Block current thread\nrunBlocking {\n    // Used in main functions or tests\n    delay(1000)\n    println(\"After delay\")\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_coroutines_theory_5", "questionText": "How do you handle errors and exceptions in Kotlin coroutines?", "type": "THEORY", "correctAnswer": "Errors in coroutines are handled through: 1) try-catch blocks within coroutines, 2) CoroutineExceptionHandler for uncaught exceptions, 3) supervisorScope to prevent cancellation of sibling coroutines, and 4) structured concurrency which propagates exceptions up the hierarchy. By default, uncaught exceptions cancel the coroutine and its parent.", "explanation": "Exception handling differs between different coroutine builders. In launch, exceptions are propagated to the parent. In async, they're stored in the Deferred and thrown on await(). In supervisorScope, child failures don't affect siblings or parents.", "codeExample": "// Exception handler\nval handler = CoroutineExceptionHandler { _, exception ->\n    println(\"Caught $exception\")\n}\n\n// Using try-catch\nlaunch {\n    try {\n        riskyOperation()\n    } catch (e: Exception) {\n        handleError(e)\n    }\n}\n\n// Using exception handler\nlaunch(handler) {\n    riskyOperation()\n}\n\n// Using supervisorScope\nsupervisorScope {\n    launch { task1() } // Failure here doesn't affect task2\n    launch { task2() }\n}", "difficulty": "HARD"}
  ]
}