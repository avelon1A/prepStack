{
  "topicId": "kotlin_oop",
  "questions": [
    {"id": "kotlin_oop_theory_1", "questionText": "What are data classes in Kotlin and how do they differ from regular classes?", "type": "THEORY", "correctAnswer": "Data classes are classes designed to hold data, automatically generating equals(), hashCode(), toString(), and copy() methods. They are declared with the 'data' keyword before 'class'. Unlike regular classes, they focus on data storage with less boilerplate code.", "explanation": "Data classes are optimized for storing and manipulating data, requiring at least one primary constructor parameter. They're ideal for POJOs/DTOs while regular classes have a broader scope.", "codeExample": "// Data class\ndata class Person(val name: String, val age: Int)\n\n// Regular class equivalent would require implementing:\n// equals(), hashCode(), toString(), component functions for destructuring", "difficulty": "EASY"},
    
    {"id": "kotlin_oop_theory_2", "questionText": "Explain companion objects in Kotlin and how they compare to static members in Java.", "type": "THEORY", "correctAnswer": "Companion objects are singleton objects declared inside a class, providing a way to define members that are tied to the class rather than instances. They're accessed using the class name as qualifier. Unlike Java's static members, companion objects can implement interfaces, inherit from classes, and maintain state.", "explanation": "Kotlin doesn't have static members, but companion objects serve a similar purpose while being more powerful. The @JvmStatic annotation can be used to expose companion object methods as actual static methods to Java code.", "codeExample": "class MyClass {\n    companion object {\n        const val MAX_COUNT = 100\n        fun create(): MyClass = MyClass()\n    }\n}\n\n// Usage\nval max = MyClass.MAX_COUNT\nval instance = MyClass.create()", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_oop_theory_3", "questionText": "What is the difference between 'open', 'abstract', and 'sealed' classes in Kotlin?", "type": "THEORY", "correctAnswer": "Open classes can be inherited from, but are concrete and can be instantiated. Abstract classes cannot be instantiated and may contain abstract members that must be implemented by subclasses. Sealed classes restrict the class hierarchy, allowing only specific subclasses defined in the same file, making them useful for representing restricted hierarchies like in expressions or UI states.", "explanation": "By default, Kotlin classes are final (non-inheritable). These modifiers provide different levels of inheritance control and use cases.", "codeExample": "// Open class - can be extended\nopen class Animal {\n    open fun makeSound() { println(\"Some sound\") }\n}\n\n// Abstract class - cannot be instantiated\nabstract class Shape {\n    abstract fun area(): Double\n}\n\n// Sealed class - restricted hierarchy\nsealed class Result {\n    data class Success(val data: Any): Result()\n    data class Error(val message: String): Result()\n    object Loading : Result()\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_oop_theory_4", "questionText": "How do Kotlin's properties differ from Java's fields? Explain property accessors.", "type": "THEORY", "correctAnswer": "Kotlin properties combine fields and accessors, providing built-in getter/setter functionality. Properties can be declared as mutable (var) or read-only (val). Custom accessors allow controlling how properties are read or modified, and can implement computed properties. Properties can also have backing fields, delegated implementation, or be extension properties.", "explanation": "This approach reduces boilerplate code while providing encapsulation. Properties can also have visibility modifiers different from their accessors.", "codeExample": "class Rectangle(val width: Int, val height: Int) {\n    // Read-only computed property\n    val area: Int\n        get() = width * height\n    \n    // Property with custom getter and setter\n    var displayName: String = \"Rectangle\"\n        get() = field.uppercase()\n        set(value) {\n            field = if (value.isBlank()) \"Unnamed\" else value\n        }\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_oop_theory_5", "questionText": "What are object expressions, object declarations, and how do they relate to the Singleton pattern?", "type": "THEORY", "correctAnswer": "Object expressions create anonymous objects on the fly, similar to anonymous classes in Java. Object declarations define singletons - classes with exactly one instance. They're declared using the 'object' keyword instead of 'class'. Object declarations provide a clean, thread-safe implementation of the Singleton pattern, with lazy initialization by default.", "explanation": "Object expressions are useful for one-time use, while object declarations create reusable singletons that are initialized on first access (thread-safely).", "codeExample": "// Object expression (anonymous object)\nval listener = object : MouseAdapter() {\n    override fun mouseClicked(e: MouseEvent) { /*...*/ }\n    override fun mouseEntered(e: MouseEvent) { /*...*/ }\n}\n\n// Object declaration (singleton)\nobject DatabaseConnection {\n    private val connection: Connection? = null\n    fun connect() {\n        // Initialize connection once\n    }\n}", "difficulty": "HARD"}
  ]
}