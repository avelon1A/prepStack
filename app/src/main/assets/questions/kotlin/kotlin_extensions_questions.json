{
  "topicId": "kotlin_extensions",
  "questions": [
    {"id": "kotlin_ext_theory_1", "questionText": "What are extension functions in Kotlin and what problem do they solve?", "type": "THEORY", "correctAnswer": "Extension functions are a way to add new functionality to existing classes without modifying their source code or inheriting from them. They're declared outside the class but can be called as if they were methods of that class. This solves the problem of extending closed classes or adding utility functions without modifying original code or using inheritance or design patterns like Decorator.", "explanation": "Extensions are resolved statically, so they don't actually modify the extended class. They're particularly useful for adding utility methods to standard library classes or platform classes that you can't modify.", "codeExample": "// Extension function for String\nfun String.isPalindrome(): Boolean {\n    val cleaned = this.lowercase().filter { it.isLetterOrDigit() }\n    return cleaned == cleaned.reversed()\n}\n\n// Usage\nval result = \"A man, a plan, a canal: Panama\".isPalindrome() // true", "difficulty": "EASY"},
    
    {"id": "kotlin_ext_theory_2", "questionText": "What are extension properties and how do they differ from extension functions?", "type": "THEORY", "correctAnswer": "Extension properties allow adding new properties to existing classes without modifying their source code. They differ from extension functions in that they cannot have backing fields, so they must be implemented using custom getters (and setters for mutable properties). They provide a property-like syntax for computations that don't require parameters.", "explanation": "Extension properties are useful for adding computed values that logically belong to a class but can't be added directly. They're particularly helpful for improving readability by using property syntax instead of parameterless methods.", "codeExample": "// Extension property\nval String.isPalindrome: Boolean\n    get() {\n        val cleaned = this.lowercase().filter { it.isLetterOrDigit() }\n        return cleaned == cleaned.reversed()\n    }\n\n// Usage\nif (\"level\".isPalindrome) {\n    println(\"It's a palindrome\")\n}\n\n// Extension property with custom setter\nvar StringBuilder.lastChar: Char\n    get() = get(length - 1)\n    set(value) {\n        this.setCharAt(length - 1, value)\n    }", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_ext_theory_3", "questionText": "What are scope functions in Kotlin and how are they used?", "type": "THEORY", "correctAnswer": "Scope functions are extension functions that create a temporary scope for an object, allowing operations on that object without repeating its name. The main scope functions are: let (it, returns lambda result), run (this, returns lambda result), with (this, returns lambda result), apply (this, returns the object), and also (it, returns the object). They're used for making code more concise and readable when performing multiple operations on an object.", "explanation": "Each scope function serves a specific use case: 'let' for null-safety operations, 'run' for object configuration and calculations, 'with' for operating on non-null objects, 'apply' for object configuration, and 'also' for additional effects or logging.", "codeExample": "// let - Executes a block with 'it' and returns the result\nperson?.let {\n    println(\"Name: ${it.name}\")\n    it.age\n} // Returns age or null if person is null\n\n// run - Executes a block with 'this' and returns the result\nperson.run {\n    println(\"Name: $name\")\n    age\n} // Returns age\n\n// apply - Configures object with 'this' and returns the object\nperson.apply {\n    name = \"John\"\n    age = 30\n} // Returns modified person object\n\n// also - Executes a block with 'it' and returns the object\nperson.also {\n    println(\"Person created: ${it.name}\")\n} // Returns person object\n\n// with - Executes a block with 'this' on a non-null object\nwith(person) {\n    println(\"Name: $name\")\n    age\n} // Returns age", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_ext_theory_4", "questionText": "What is a Domain-Specific Language (DSL) and how does Kotlin support building DSLs?", "type": "THEORY", "correctAnswer": "A Domain-Specific Language is a specialized language tailored for a specific application domain. Kotlin supports building type-safe DSLs through a combination of features: extension functions, lambda expressions with receivers, function literals with receivers, operator overloading, infix functions, and trailing lambda syntax. These features allow creating declarative, readable APIs that resemble custom languages within Kotlin code.", "explanation": "Kotlin DSLs provide a powerful way to create declarative, fluent APIs for specific domains, improving code readability and reducing errors by leveraging the type system. Common uses include configuration, testing frameworks, HTML builders, and UI construction.", "codeExample": "// Example of a Kotlin HTML DSL\nhtml {\n    head {\n        title(\"DSL Example\")\n    }\n    body {\n        h1(\"Kotlin DSLs are powerful\")\n        p {\n            +(\"They allow creating \") \n            b(\"expressive code\")\n        }\n        ul {\n            for (item in listOf(\"Type-safe\", \"Concise\", \"Readable\")) {\n                li(item)\n            }\n        }\n    }\n}\n\n// Implementation structure (simplified)\nclass HTML {\n    fun head(init: Head.() -> Unit): Head = Head().apply(init)\n    fun body(init: Body.() -> Unit): Body = Body().apply(init)\n}\n\nfun html(init: HTML.() -> Unit): HTML = HTML().apply(init)", "difficulty": "HARD"},
    
    {"id": "kotlin_ext_theory_5", "questionText": "What are the scoping rules for extensions in Kotlin? How does Kotlin resolve extension functions?", "type": "THEORY", "correctAnswer": "Extensions in Kotlin are resolved statically based on the declared type of the variable, not its runtime type. They must be imported explicitly to be used, and they don't actually modify the extended class. When there's a name conflict between a member function and an extension function, the member function always takes precedence. Extensions declared as members can access private members of the class they're declared in.", "explanation": "Understanding these scoping rules is crucial for correctly using extensions and avoiding unexpected behavior, especially when working with inheritance or generic types.", "codeExample": "// Extensions are resolved statically\nopen class Shape\nclass Circle : Shape()\n\nfun Shape.getName() = \"Shape\"\nfun Circle.getName() = \"Circle\"\n\nfun main() {\n    val circle: Circle = Circle()\n    println(circle.getName()) // Prints \"Circle\"\n    \n    val shape: Shape = circle\n    println(shape.getName()) // Prints \"Shape\" (static dispatch)\n}\n\n// Member function takes precedence over extension\nclass Example {\n    fun foo() = \"member\"\n}\n\nfun Example.foo() = \"extension\"\n\nfun main() {\n    println(Example().foo()) // Prints \"member\"\n}", "difficulty": "HARD"}
  ]
}