{
  "topicId": "kotlin_interop",
  "questions": [
    {"id": "kotlin_interop_theory_1", "questionText": "How does Kotlin achieve interoperability with Java?", "type": "THEORY", "correctAnswer": "Kotlin achieves Java interoperability through: 1) JVM bytecode compatibility - Kotlin compiles to the same bytecode as Java, 2) Seamless calling between languages - Kotlin code can call Java code and vice versa, 3) Kotlin-specific features translated to Java-compatible constructs (e.g., extension functions become static methods), 4) Annotations to customize Java interaction (@JvmStatic, @JvmOverloads, etc.), and 5) Special handling of Java platform types for null-safety.", "explanation": "This interoperability allows for gradual migration from Java to Kotlin and leveraging existing Java libraries in Kotlin projects. Kotlin was specifically designed with Java interoperability as a primary goal.", "difficulty": "EASY"},
    
    {"id": "kotlin_interop_theory_2", "questionText": "What are platform types in Kotlin and how do they affect interoperability with Java?", "type": "THEORY", "correctAnswer": "Platform types in Kotlin represent types coming from Java that have unknown nullability. They're represented with a ! symbol (e.g., String!). Since Java doesn't enforce null safety at compile time, Kotlin treats Java types as potentially nullable but doesn't force null checks. This makes interaction with Java code more convenient but retains some risk of NullPointerExceptions at runtime.", "explanation": "Kotlin doesn't add explicit ?, but when you use a platform type, you're responsible for ensuring the value isn't null. Platform types are a compromise between safety and convenience in the interop boundary.", "codeExample": "// Java code\npublic class JavaClass {\n    public String getValue() { return \"value\"; }\n    public String getNullableValue() { return null; }\n}\n\n// Kotlin code using Java class\nfun processJavaValues(javaObj: JavaClass) {\n    // Platform type String! (unknown nullability)\n    val value = javaObj.value\n    \n    // Works fine because value is not null\n    val length = value.length\n    \n    // No compiler error, but potential NPE at runtime\n    val nullableLength = javaObj.nullableValue.length\n    \n    // Safe approach\n    val safeLength = javaObj.nullableValue?.length ?: 0\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_interop_theory_3", "questionText": "What annotations does Kotlin provide to customize Java interoperability?", "type": "THEORY", "correctAnswer": "Kotlin provides several annotations for Java interoperability: @JvmStatic makes companion object or object functions/properties static in Java, @JvmField exposes properties as public fields without getters/setters, @JvmOverloads generates Java method overloads for default parameters, @JvmName changes the generated method name, @Throws declares exceptions for Java callers, and @JvmWildcard controls wildcards in generic types.", "explanation": "These annotations give fine-grained control over how Kotlin code appears to Java callers, allowing you to customize the interoperability behavior to match Java conventions or make Kotlin code more idiomatic for Java developers.", "codeExample": "class Example {\n    companion object {\n        // In Java: Example.getINSTANCE()\n        @JvmStatic val INSTANCE = Example()\n        \n        // In Java: Example.createExample(\"name\"), Example.createExample(\"name\", 42)\n        @JvmStatic @JvmOverloads fun createExample(name: String, age: Int = 0) = Example()\n    }\n    \n    // In Java: example.publicField (no getter)\n    @JvmField val publicField = \"value\"\n    \n    // In Java: example.processData(data)\n    @JvmName(\"processData\")\n    fun process(data: String) {}\n    \n    // In Java: try { example.connect(); } catch (IOException e) {}\n    @Throws(IOException::class)\n    fun connect() {}\n}", "difficulty": "HARD"},
    
    {"id": "kotlin_interop_theory_4", "questionText": "How are Kotlin's properties exposed to Java code?", "type": "THEORY", "correctAnswer": "By default, Kotlin properties are exposed to Java as getter and setter methods following the JavaBean convention (get/set prefix). For example, a property 'name' generates getName() and setName() in Java. Properties in companion objects or objects become instance methods on the companion/object instance unless annotated with @JvmStatic. Properties can be exposed as public fields using the @JvmField annotation, or completely customized by manually writing get/set functions.", "explanation": "This automatic conversion allows Java code to interact with Kotlin properties in a natural way for Java developers, while Kotlin code can use the more concise property syntax. It's a key aspect of the seamless interoperability between the two languages.", "codeExample": "// Kotlin\nclass Person {\n    // In Java: person.getName() and person.setName(\"John\")\n    var name: String = \"\"\n    \n    // In Java: person.isActive() and person.setActive(true)\n    var isActive: Boolean = false\n    \n    // In Java: person.age (direct field access)\n    @JvmField var age: Int = 0\n    \n    // In Java: person.getCustomValue()\n    val customValue: String\n        get() = computeValue()\n    \n    // In Java: Person.INSTANCE.getMAX_AGE()\n    companion object {\n        const val MAX_AGE = 120\n        \n        // In Java: Person.getDefaultName()\n        @JvmStatic val DEFAULT_NAME = \"Unknown\"\n    }\n}", "difficulty": "MEDIUM"},
    
    {"id": "kotlin_interop_theory_5", "questionText": "How do Kotlin's extension functions work when called from Java code?", "type": "THEORY", "correctAnswer": "Extension functions in Kotlin are compiled to static methods in Java, with the receiver object as the first parameter. For example, an extension function 'String.getFirstChar()' becomes 'StringKt.getFirstChar(String)' in Java. The name of the generated class is based on the Kotlin file name (e.g., StringExtensionsKt). The @JvmName annotation can be used to customize this class name.", "explanation": "This approach allows Kotlin to implement extension functions without modifying existing classes, while still making them callable from Java code, albeit with different syntax. Understanding this transformation is important for designing APIs that need to be used from both languages.", "codeExample": "// Kotlin file: StringExtensions.kt\nfun String.wordCount(): Int = this.split(\" \").size\n\n@JvmName(\"StringUtils\")\npackage com.example\n\nfun String.capitalize(): String = this.uppercase()\n\n// Java usage\nimport com.example.StringExtensionsKt;\nimport com.example.StringUtils;\n\nclass JavaClass {\n    void example() {\n        // Call extensions as static methods\n        int count = StringExtensionsKt.wordCount(\"Hello World\");\n        String capitalized = StringUtils.capitalize(\"hello\");\n    }\n}", "difficulty": "HARD"}
  ]
}