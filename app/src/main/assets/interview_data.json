{
  "domains": [
    {
      "id": "android",
      "name": "Android",
      "description": "Android app development concepts and best practices",
      "iconUrl": "https://img.icons8.com/color/96/android-os.png",
      "topics": [
        {
          "id": "android_basics",
          "name": "Android Basics",
          "description": "Core Android concepts and architecture",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "android_theory_1",
              "questionText": "What is an Activity in Android?",
              "type": "THEORY",
              "correctAnswer": "An Activity represents a single screen with a user interface in an Android application. It acts as an entry point for user interaction and manages the lifecycle of the screen.",
              "explanation": "Activities are fundamental building blocks of Android apps. Each activity has its own lifecycle (onCreate, onStart, onResume, onPause, onStop, onDestroy) and can be started from other activities or the system.",
              "codeExample": "class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "android_theory_2",
              "questionText": "What is a Service in Android?",
              "type": "THEORY",
              "correctAnswer": "A Service is an application component that can perform long-running operations in the background without a user interface.",
              "explanation": "Services continue running even if the user switches to another application. They are ideal for tasks like playing music, downloading files, or syncing data.",
              "codeExample": "class MusicService : Service() {\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n        return START_STICKY\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_theory_3",
              "questionText": "What is AndroidManifest.xml?",
              "type": "THEORY",
              "correctAnswer": "AndroidManifest.xml is a crucial configuration file that provides essential information about your app to the Android system.",
              "explanation": "The manifest file declares all app components, required permissions, minimum API level, hardware and software features, and other metadata.",
              "codeExample": "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <application>\n        <activity android:name=\".MainActivity\" />\n    </application>\n</manifest>",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "android_theory_4",
              "questionText": "What is the difference between onCreate() and onStart()?",
              "type": "THEORY",
              "correctAnswer": "onCreate() is called when the activity is first created and is where you initialize your app. onStart() is called when the activity becomes visible to the user.",
              "explanation": "onCreate() is called once during the activity's lifetime and is where you should do one-time initializations. onStart() is called every time the activity becomes visible, including after being hidden.",
              "codeExample": "override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContentView(R.layout.activity_main)\n    // One-time initialization\n}\n\noverride fun onStart() {\n    super.onStart()\n    // Called when activity becomes visible\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_theory_5",
              "questionText": "What is a Broadcast Receiver?",
              "type": "THEORY",
              "correctAnswer": "A Broadcast Receiver is a component that responds to system-wide broadcast announcements or messages from other apps.",
              "explanation": "Broadcast Receivers allow your app to respond to system events like battery low, network change, or boot completed. They can be registered in the manifest or dynamically in code.",
              "codeExample": "class MyReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        // Handle broadcast\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_theory_6",
              "questionText": "What is a Content Provider?",
              "type": "THEORY",
              "correctAnswer": "A Content Provider manages access to a structured set of data and enables data sharing between different applications.",
              "explanation": "Content Providers encapsulate data and provide mechanisms for defining data security. They are the standard interface for connecting data in one process with code running in another process.",
              "codeExample": "class MyProvider : ContentProvider() {\n    override fun query(uri: Uri, projection: Array<String>?, selection: String?, selectionArgs: Array<String>?, sortOrder: String?): Cursor {\n        // Query implementation\n    }\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "android_theory_7",
              "questionText": "What is the difference between px, dp, and sp?",
              "type": "THEORY",
              "correctAnswer": "px is actual screen pixels. dp (density-independent pixels) is abstract units that scale based on screen density. sp (scale-independent pixels) is like dp but also scales based on user's font size preference.",
              "explanation": "Use dp for layout dimensions to ensure consistent sizing across different screen densities. Use sp for text sizes to respect user's font size settings. Avoid using px directly.",
              "codeExample": "// dp to px conversion\nval dp = 16f\nval px = dp * resources.displayMetrics.density\n\n// sp for text\nText(text = \"Hello\", fontSize = 16.sp)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "android_theory_8",
              "questionText": "What is the Android Application Class?",
              "type": "THEORY",
              "correctAnswer": "The Application class is the base class for maintaining global application state and is created before any other component when the app process starts.",
              "explanation": "You can extend Application to maintain global state, initialize libraries, or handle app-level events. It's optional and should be used sparingly.",
              "codeExample": "class MyApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        // Initialize libraries\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "android_quiz_1",
              "questionText": "Which component is used to perform background operations in Android?",
              "type": "MCQ",
              "options": ["Activity", "Service", "Broadcast Receiver", "Content Provider"],
              "correctAnswer": "Service",
              "explanation": "Services are application components that can perform long-running operations in the background without a user interface.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_2",
              "questionText": "What is the purpose of AndroidManifest.xml?",
              "type": "MCQ",
              "options": ["It defines app's UI layouts", "It declares app components and permissions", "It stores app data", "It handles network requests"],
              "correctAnswer": "It declares app components and permissions",
              "explanation": "AndroidManifest.xml provides essential information about your app to the Android system.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_3",
              "questionText": "What is the primary purpose of ViewModel in Android?",
              "type": "MCQ",
              "options": ["To handle database operations", "To manage UI-related data in a lifecycle-conscious way", "To create custom views", "To handle network requests"],
              "correctAnswer": "To manage UI-related data in a lifecycle-conscious way",
              "explanation": "ViewModel allows data to survive configuration changes such as screen rotations.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_4",
              "questionText": "Which lifecycle method is called when an Activity becomes visible?",
              "type": "MCQ",
              "options": ["onCreate()", "onStart()", "onResume()", "onPause()"],
              "correctAnswer": "onStart()",
              "explanation": "onStart() is called when the activity becomes visible to the user.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_5",
              "questionText": "What is an Intent in Android?",
              "type": "MCQ",
              "options": ["A messaging object for UI updates", "A messaging object to request an action from another component", "A database query object", "A network request object"],
              "correctAnswer": "A messaging object to request an action from another component",
              "explanation": "Intent is a messaging object that can be used to request an action from another app component.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_6",
              "questionText": "What is a Fragment in Android?",
              "type": "MCQ",
              "options": ["A reusable portion of your app's UI", "A type of Activity", "A database table", "A network connection"],
              "correctAnswer": "A reusable portion of your app's UI",
              "explanation": "A Fragment represents a reusable portion of your app's UI with its own lifecycle.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_7",
              "questionText": "What is LiveData in Android Architecture Components?",
              "type": "MCQ",
              "options": ["A real-time database", "An observable data holder class that is lifecycle-aware", "A network library", "A UI component"],
              "correctAnswer": "An observable data holder class that is lifecycle-aware",
              "explanation": "LiveData respects the lifecycle of other app components and prevents memory leaks.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_8",
              "questionText": "What is the purpose of RecyclerView?",
              "type": "MCQ",
              "options": ["To recycle unused memory", "To efficiently display large lists of data", "To manage app lifecycle", "To handle background tasks"],
              "correctAnswer": "To efficiently display large lists of data",
              "explanation": "RecyclerView efficiently displays large data sets by recycling views.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_9",
              "questionText": "Which method is used to inflate a layout in a Fragment?",
              "type": "MCQ",
              "options": ["onCreate()", "onCreateView()", "onViewCreated()", "onAttach()"],
              "correctAnswer": "onCreateView()",
              "explanation": "onCreateView() is where you inflate the fragment's layout XML.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_10",
              "questionText": "What does 'suspend' keyword indicate in Kotlin?",
              "type": "MCQ",
              "options": ["The function runs on main thread", "The function can be paused and resumed", "The function is deprecated", "The function is private"],
              "correctAnswer": "The function can be paused and resumed",
              "explanation": "The suspend keyword marks a function as a coroutine that can be paused and resumed.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_11",
              "questionText": "What is the difference between finish() and finishAffinity()?",
              "type": "MCQ",
              "options": ["No difference", "finish() closes current activity, finishAffinity() closes all activities in the same task", "finishAffinity() closes only the current activity", "finish() closes all activities"],
              "correctAnswer": "finish() closes current activity, finishAffinity() closes all activities in the same task",
              "explanation": "finishAffinity() removes all activities from the task that have the same affinity as the current activity.",
              "difficulty": "HARD"
            },
            {
              "id": "android_quiz_12",
              "questionText": "What is the purpose of Context in Android?",
              "type": "MCQ",
              "options": ["To store app data", "To provide access to app-level resources and services", "To handle UI events", "To manage network connections"],
              "correctAnswer": "To provide access to app-level resources and services",
              "explanation": "Context provides access to application-specific resources and classes, as well as up-calls for application-level operations.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "android_quiz_13",
              "questionText": "Which storage option is best for storing small key-value pairs?",
              "type": "MCQ",
              "options": ["SQLite Database", "SharedPreferences", "Internal Storage", "External Storage"],
              "correctAnswer": "SharedPreferences",
              "explanation": "SharedPreferences is ideal for storing small key-value pairs like settings and preferences.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_14",
              "questionText": "What is the difference between margin and padding?",
              "type": "MCQ",
              "options": ["No difference", "Margin is outside the view, padding is inside", "Padding is outside the view, margin is inside", "Both are the same"],
              "correctAnswer": "Margin is outside the view, padding is inside",
              "explanation": "Margin creates space around the view's border, while padding creates space between the view's border and its content.",
              "difficulty": "EASY"
            },
            {
              "id": "android_quiz_15",
              "questionText": "What is the purpose of the Adapter pattern in Android?",
              "type": "MCQ",
              "options": ["To handle network requests", "To bridge data and UI components like ListView/RecyclerView", "To manage app lifecycle", "To store data"],
              "correctAnswer": "To bridge data and UI components like ListView/RecyclerView",
              "explanation": "Adapters act as a bridge between an AdapterView (like ListView or RecyclerView) and the underlying data for that view.",
              "difficulty": "MEDIUM"
            }
          ]
        },
        {
          "id": "android_jetpack",
          "name": "Jetpack Compose",
          "description": "Modern toolkit for building native Android UI",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "compose_theory_1",
              "questionText": "What is Jetpack Compose?",
              "type": "THEORY",
              "correctAnswer": "Jetpack Compose is Android's modern toolkit for building native UI using a declarative approach with Kotlin.",
              "explanation": "Compose simplifies and accelerates UI development by allowing you to describe your UI in composable functions.",
              "codeExample": "@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello $name!\")\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "compose_theory_2",
              "questionText": "What is a Composable function?",
              "type": "THEORY",
              "correctAnswer": "A Composable function is a function annotated with @Composable that describes a piece of UI and can emit UI elements.",
              "explanation": "Composable functions are the building blocks of Compose UI. They can call other composable functions and can accept parameters to customize their behavior.",
              "codeExample": "@Composable\nfun MyButton(text: String, onClick: () -> Unit) {\n    Button(onClick = onClick) {\n        Text(text)\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "compose_theory_3",
              "questionText": "What is State in Jetpack Compose?",
              "type": "THEORY",
              "correctAnswer": "State in Compose is any value that can change over time and affects the UI. When state changes, Compose automatically recomposes the affected composables.",
              "explanation": "State is the single source of truth for your UI. Compose tracks state changes and efficiently updates only the composables that depend on that state.",
              "codeExample": "@Composable\nfun Counter() {\n    var count by remember { mutableStateOf(0) }\n    Button(onClick = { count++ }) {\n        Text(\"Count: $count\")\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_theory_4",
              "questionText": "What is the difference between remember and rememberSaveable?",
              "type": "THEORY",
              "correctAnswer": "remember keeps state across recompositions but loses it on configuration changes. rememberSaveable keeps state across recompositions and survives configuration changes.",
              "explanation": "Use remember for transient state that doesn't need to survive configuration changes. Use rememberSaveable for state that should persist across screen rotations and process death.",
              "codeExample": "// Lost on rotation\nvar count by remember { mutableStateOf(0) }\n\n// Survives rotation\nvar count by rememberSaveable { mutableStateOf(0) }",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_theory_5",
              "questionText": "What is LaunchedEffect in Compose?",
              "type": "THEORY",
              "correctAnswer": "LaunchedEffect is a composable that launches a coroutine tied to the scope of the composition. It runs when the composition enters and is cancelled when it leaves.",
              "explanation": "LaunchedEffect is useful for running side effects like making network calls, showing animations, or triggering one-time events when a composable enters the composition.",
              "codeExample": "LaunchedEffect(key1) {\n    // Run coroutine\n    delay(1000)\n    // Do something\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "compose_quiz_1",
              "questionText": "What is the main advantage of Jetpack Compose over XML layouts?",
              "type": "MCQ",
              "options": ["Better performance", "Declarative UI paradigm", "Smaller APK size", "Better backward compatibility"],
              "correctAnswer": "Declarative UI paradigm",
              "explanation": "Compose uses a declarative approach where you describe what the UI should look like based on the current state.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_quiz_2",
              "questionText": "What annotation is used to mark a function as a Composable?",
              "type": "MCQ",
              "options": ["@Composable", "@Compose", "@UI", "@View"],
              "correctAnswer": "@Composable",
              "explanation": "The @Composable annotation tells the Compose compiler that this function describes UI.",
              "difficulty": "EASY"
            },
            {
              "id": "compose_quiz_3",
              "questionText": "What function is used to create observable state in Compose?",
              "type": "MCQ",
              "options": ["stateOf()", "mutableStateOf()", "createState()", "observeState()"],
              "correctAnswer": "mutableStateOf()",
              "explanation": "mutableStateOf() creates an observable state that triggers recomposition when its value changes.",
              "difficulty": "EASY"
            },
            {
              "id": "compose_quiz_4",
              "questionText": "What is the purpose of the remember function?",
              "type": "MCQ",
              "options": ["To save data to disk", "To keep state across recompositions", "To remember user preferences", "To cache network responses"],
              "correctAnswer": "To keep state across recompositions",
              "explanation": "remember keeps a value across recompositions so it doesn't get reset every time the composable recomposes.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_quiz_5",
              "questionText": "What is SideEffect in Compose?",
              "type": "MCQ",
              "options": ["A function that runs on every recomposition", "A function that runs once when the composable enters composition", "A function that publishes Compose state to non-Compose code", "A function that handles errors"],
              "correctAnswer": "A function that publishes Compose state to non-Compose code",
              "explanation": "SideEffect is used to perform side effects that should run on every recomposition, like updating non-Compose code based on Compose state.",
              "difficulty": "HARD"
            },
            {
              "id": "compose_quiz_6",
              "questionText": "What is the difference between Column and Row in Compose?",
              "type": "MCQ",
              "options": ["No difference", "Column arranges children vertically, Row arranges them horizontally", "Column arranges children horizontally, Row arranges them vertically", "Column is for text, Row is for images"],
              "correctAnswer": "Column arranges children vertically, Row arranges them horizontally",
              "explanation": "Column lays out its children in a vertical sequence, while Row lays them out horizontally.",
              "difficulty": "EASY"
            },
            {
              "id": "compose_quiz_7",
              "questionText": "What is the purpose of the Box composable?",
              "type": "MCQ",
              "options": ["To create a checkbox", "To stack children on top of each other", "To create a border", "To create a scrollable list"],
              "correctAnswer": "To stack children on top of each other",
              "explanation": "Box is used to stack children on top of each other, similar to a FrameLayout in XML.",
              "difficulty": "EASY"
            },
            {
              "id": "compose_quiz_8",
              "questionText": "What is the modifier parameter used for in Compose?",
              "type": "MCQ",
              "options": ["To change the color", "To add decorations, behavior, and layout instructions", "To add text", "To add images"],
              "correctAnswer": "To add decorations, behavior, and layout instructions",
              "explanation": "Modifier is an ordered, immutable collection of element decoration and behavior modifiers like padding, size, click listeners, etc.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_quiz_9",
              "questionText": "What is the purpose of LazyColumn in Compose?",
              "type": "MCQ",
              "options": ["To create a lazy loading image", "To efficiently display large lists by only composing visible items", "To create a column that loads slowly", "To create a column with animations"],
              "correctAnswer": "To efficiently display large lists by only composing visible items",
              "explanation": "LazyColumn is the Compose equivalent of RecyclerView, only composing and laying out items that are currently visible.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "compose_quiz_10",
              "questionText": "What is the purpose of the derivedStateOf function?",
              "type": "MCQ",
              "options": ["To create a new state from existing state", "To derive a value from a database", "To create a derived class", "To create a state that is always true"],
              "correctAnswer": "To create a new state from existing state",
              "explanation": "derivedStateOf creates a state that is calculated from other state objects, only recomputing when the dependencies change.",
              "difficulty": "HARD"
            }
          ]
        },
        {
          "id": "android_lifecycle",
          "name": "Android Lifecycle",
          "description": "Understanding Activity and Fragment lifecycle management",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "lifecycle_theory_1",
              "questionText": "What is the difference between onStart() and onResume()?",
              "type": "THEORY",
              "correctAnswer": "onStart() is called when the activity becomes visible to the user. onResume() is called when the activity starts interacting with the user.",
              "explanation": "onStart() indicates the activity is visible but may not be in the foreground. onResume() indicates the activity is in the foreground and ready for user interaction.",
              "codeExample": "override fun onStart() {\n    super.onStart()\n    // Activity is visible\n}\n\noverride fun onResume() {\n    super.onResume()\n    // Activity is in foreground and ready for interaction\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "lifecycle_theory_2",
              "questionText": "What is the purpose of onSaveInstanceState()?",
              "type": "THEORY",
              "correctAnswer": "onSaveInstanceState() is called to save transient state data before an activity may be killed by the system, allowing restoration in onCreate() or onRestoreInstanceState().",
              "explanation": "Use this method to save data that should persist across configuration changes or when the system kills the process to reclaim memory.",
              "codeExample": "override fun onSaveInstanceState(outState: Bundle) {\n    super.onSaveInstanceState(outState)\n    outState.putString(\"key\", value)\n}\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    savedInstanceState?.getString(\"key\")?.let { value = it }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_theory_3",
              "questionText": "What is the difference between onPause() and onStop()?",
              "type": "THEORY",
              "correctAnswer": "onPause() is called when the activity is partially obscured by another activity. onStop() is called when the activity is no longer visible to the user.",
              "explanation": "onPause() is used for tasks that should happen when the activity is still visible but not in focus. onStop() is for cleanup when the activity is completely hidden.",
              "codeExample": "override fun onPause() {\n    super.onPause()\n    // Stop animations, save unsaved data\n}\n\noverride fun onStop() {\n    super.onStop()\n    // Release resources, unregister listeners\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_theory_4",
              "questionText": "What is a ViewModel and how does it relate to lifecycle?",
              "type": "THEORY",
              "correctAnswer": "ViewModel is a lifecycle-aware component designed to store and manage UI-related data, surviving configuration changes like screen rotations.",
              "explanation": "ViewModel is cleared when the associated lifecycle scope (like an Activity or Fragment) is permanently destroyed, not during configuration changes.",
              "codeExample": "class MyViewModel : ViewModel() {\n    private val _data = MutableLiveData<String>()\n    val data: LiveData<String> = _data\n}\n\n// In Activity\nval viewModel = ViewModelProvider(this)[MyViewModel::class.java]",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_theory_5",
              "questionText": "What is the purpose of LifecycleObserver?",
              "type": "THEORY",
              "correctAnswer": "LifecycleObserver is an interface that allows classes to monitor lifecycle events without extending from Android lifecycle components like Activity or Fragment.",
              "explanation": "You can annotate methods with @OnLifecycleEvent to respond to lifecycle changes, making it easy to create lifecycle-aware components.",
              "codeExample": "class MyObserver : LifecycleObserver {\n    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)\n    fun onResume() {\n        // Handle resume event\n    }\n}\n\n// In Activity\nlifecycle.addObserver(MyObserver())",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "lifecycle_quiz_1",
              "questionText": "Which lifecycle method is called first when an Activity is created?",
              "type": "MCQ",
              "options": ["onStart()", "onResume()", "onCreate()", "onPause()"],
              "correctAnswer": "onCreate()",
              "explanation": "onCreate() is the first method called when an Activity is created, where you should initialize your activity.",
              "difficulty": "EASY"
            },
            {
              "id": "lifecycle_quiz_2",
              "questionText": "What happens when you call finish() in onCreate()?",
              "type": "MCQ",
              "options": ["The app crashes", "The activity is destroyed immediately", "The activity continues normally", "The activity goes to background"],
              "correctAnswer": "The activity is destroyed immediately",
              "explanation": "Calling finish() in onCreate() will destroy the activity before it becomes visible to the user.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_quiz_3",
              "questionText": "Which method is called when the user presses the Back button?",
              "type": "MCQ",
              "options": ["onDestroy()", "onPause()", "onStop()", "onBackPressed()"],
              "correctAnswer": "onBackPressed()",
              "explanation": "onBackPressed() is called when the user presses the Back button, which by default finishes the activity.",
              "difficulty": "EASY"
            },
            {
              "id": "lifecycle_quiz_4",
              "questionText": "What is the difference between onRestart() and onStart()?",
              "type": "MCQ",
              "options": ["No difference", "onRestart() is called before onStart() when activity is being restarted", "onStart() is called before onRestart()", "Both are called simultaneously"],
              "correctAnswer": "onRestart() is called before onStart() when activity is being restarted",
              "explanation": "onRestart() is called when an activity that was stopped is being started again, followed by onStart().",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_quiz_5",
              "questionText": "Which lifecycle method should you use to release resources?",
              "type": "MCQ",
              "options": ["onPause()", "onStop()", "onDestroy()", "All of the above"],
              "correctAnswer": "onDestroy()",
              "explanation": "onDestroy() is the final call before the activity is destroyed, making it the best place to release all resources.",
              "difficulty": "EASY"
            },
            {
              "id": "lifecycle_quiz_6",
              "questionText": "What is the purpose of the LifecycleOwner interface?",
              "type": "MCQ",
              "options": ["To own lifecycle observers", "To provide lifecycle information to other components", "To manage app permissions", "To handle network requests"],
              "correctAnswer": "To provide lifecycle information to other components",
              "explanation": "LifecycleOwner is an interface that allows other components to observe its lifecycle events.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_quiz_7",
              "questionText": "When is onSaveInstanceState() called?",
              "type": "MCQ",
              "options": ["Before onPause()", "Before onStop()", "Before onDestroy()", "After onResume()"],
              "correctAnswer": "Before onStop()",
              "explanation": "onSaveInstanceState() is called before onStop() when there's a possibility the activity may be killed.",
              "difficulty": "HARD"
            },
            {
              "id": "lifecycle_quiz_8",
              "questionText": "What happens to a ViewModel during screen rotation?",
              "type": "MCQ",
              "options": ["It is destroyed", "It survives the rotation", "It is recreated", "It becomes null"],
              "correctAnswer": "It survives the rotation",
              "explanation": "ViewModel is designed to survive configuration changes like screen rotations, preserving UI data.",
              "difficulty": "EASY"
            },
            {
              "id": "lifecycle_quiz_9",
              "questionText": "Which annotation is used to mark a method as a lifecycle event handler?",
              "type": "MCQ",
              "options": ["@LifecycleEvent", "@OnLifecycleEvent", "@EventHandler", "@LifecycleHandler"],
              "correctAnswer": "@OnLifecycleEvent",
              "explanation": "@OnLifecycleEvent is used to annotate methods that should be called when specific lifecycle events occur.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "lifecycle_quiz_10",
              "questionText": "What is the purpose of ProcessLifecycleOwner?",
              "type": "MCQ",
              "options": ["To monitor activity lifecycle", "To monitor the entire application's lifecycle", "To monitor service lifecycle", "To monitor fragment lifecycle"],
              "correctAnswer": "To monitor the entire application's lifecycle",
              "explanation": "ProcessLifecycleOwner provides lifecycle events for the entire application process, useful for detecting when the app goes to foreground/background.",
              "difficulty": "HARD"
            }
          ]
        },
        {
          "id": "android_fragments",
          "name": "Android Fragments",
          "description": "Working with Fragments for modular UI design",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "fragment_theory_1",
              "questionText": "What is a Fragment in Android?",
              "type": "THEORY",
              "correctAnswer": "A Fragment is a reusable portion of your app's UI that has its own lifecycle and can be added to an Activity or other Fragments.",
              "explanation": "Fragments allow you to create modular and reusable UI components. They can be dynamically added, removed, or replaced within an Activity.",
              "codeExample": "class MyFragment : Fragment() {\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return inflater.inflate(R.layout.fragment_my, container, false)\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_theory_2",
              "questionText": "What is the difference between Activity and Fragment?",
              "type": "THEORY",
              "correctAnswer": "An Activity is a standalone screen with its own window. A Fragment is a modular UI component that must be hosted within an Activity.",
              "explanation": "Activities can exist independently and have their own window. Fragments are dependent on Activities and cannot exist without a host.",
              "codeExample": "// Activity - standalone\nclass MainActivity : AppCompatActivity() {\n    // ...\n}\n\n// Fragment - must be hosted\nclass MyFragment : Fragment() {\n    // ...\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_theory_3",
              "questionText": "What is FragmentManager and what is its purpose?",
              "type": "THEORY",
              "correctAnswer": "FragmentManager is responsible for managing Fragments within an Activity, including adding, removing, replacing, and handling Fragment transactions.",
              "explanation": "FragmentManager handles the Fragment back stack, transactions, and communication between Fragments and their host Activity.",
              "codeExample": "val fragmentManager = supportFragmentManager\n\n// Add fragment\nfragmentManager.beginTransaction()\n    .add(R.id.container, MyFragment())\n    .commit()",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_theory_4",
              "questionText": "What is the difference between add() and replace() in Fragment transactions?",
              "type": "THEORY",
              "correctAnswer": "add() adds a Fragment to the container without removing existing ones. replace() removes all existing Fragments in the container before adding the new one.",
              "explanation": "Use add() when you want to stack Fragments on top of each other. Use replace() when you want to swap Fragments, which is more common for navigation.",
              "codeExample": "// Add - keeps existing fragments\nsupportFragmentManager.beginTransaction()\n    .add(R.id.container, fragment)\n    .commit()\n\n// Replace - removes existing fragments\nsupportFragmentManager.beginTransaction()\n    .replace(R.id.container, fragment)\n    .commit()",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_theory_5",
              "questionText": "What is the Fragment back stack?",
              "type": "THEORY",
              "correctAnswer": "The Fragment back stack is a history of Fragment transactions that allows users to navigate back through Fragment changes using the Back button.",
              "explanation": "When you add a transaction to the back stack using addToBackStack(), the user can press Back to reverse that transaction.",
              "codeExample": "supportFragmentManager.beginTransaction()\n    .replace(R.id.container, fragment)\n    .addToBackStack(null) // Adds to back stack\n    .commit()",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_theory_6",
              "questionText": "How do you pass data between Fragments?",
              "type": "THEORY",
              "correctAnswer": "You can pass data between Fragments using Bundle arguments, ViewModel, or interface callbacks depending on the use case.",
              "explanation": "Bundle arguments are for simple data. ViewModel is for shared state. Interface callbacks are for communication with the host Activity.",
              "codeExample": "// Using Bundle\nval fragment = MyFragment()\nval args = Bundle()\nargs.putString(\"key\", \"value\")\nfragment.arguments = args\n\n// Using ViewModel\nval viewModel = ViewModelProvider(requireActivity())[SharedViewModel::class.java]",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "fragment_quiz_1",
              "questionText": "Which method is used to inflate a Fragment's layout?",
              "type": "MCQ",
              "options": ["onCreate()", "onCreateView()", "onViewCreated()", "onStart()"],
              "correctAnswer": "onCreateView()",
              "explanation": "onCreateView() is where you inflate and return the Fragment's layout.",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_quiz_2",
              "questionText": "What is the purpose of onViewCreated()?",
              "type": "MCQ",
              "options": ["To create the view", "To initialize views after they are created", "To destroy the view", "To handle clicks"],
              "correctAnswer": "To initialize views after they are created",
              "explanation": "onViewCreated() is called after onCreateView() and is the ideal place to initialize views and set up listeners.",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_quiz_3",
              "questionText": "Which method is used to get the Fragment's host Activity?",
              "type": "MCQ",
              "options": ["getActivity()", "getContext()", "requireActivity()", "Both getActivity() and requireActivity()"],
              "correctAnswer": "Both getActivity() and requireActivity()",
              "explanation": "getActivity() returns nullable Activity, while requireActivity() throws an exception if Activity is null.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_quiz_4",
              "questionText": "What is the difference between commit() and commitNow()?",
              "type": "MCQ",
              "options": ["No difference", "commit() is asynchronous, commitNow() is synchronous", "commitNow() is asynchronous, commit() is synchronous", "Both are synchronous"],
              "correctAnswer": "commit() is asynchronous, commitNow() is synchronous",
              "explanation": "commit() schedules the transaction to run asynchronously. commitNow() executes it immediately but cannot be used with addToBackStack().",
              "difficulty": "HARD"
            },
            {
              "id": "fragment_quiz_5",
              "questionText": "How do you remove a Fragment?",
              "type": "MCQ",
              "options": ["fragment.remove()", "fragmentManager.remove(fragment)", "beginTransaction().remove(fragment).commit()", "fragment.delete()"],
              "correctAnswer": "beginTransaction().remove(fragment).commit()",
              "explanation": "You use a FragmentTransaction to remove a Fragment from its container.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_quiz_6",
              "questionText": "What is the purpose of findFragmentById()?",
              "type": "MCQ",
              "options": ["To find a Fragment by its ID", "To find a Fragment by its tag", "To create a new Fragment", "To delete a Fragment"],
              "correctAnswer": "To find a Fragment by its ID",
              "explanation": "findFragmentById() retrieves a Fragment that was added to the Activity with a specific container ID.",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_quiz_7",
              "questionText": "What is the difference between Fragment and DialogFragment?",
              "type": "MCQ",
              "options": ["No difference", "DialogFragment displays as a floating dialog", "Fragment displays as a dialog", "DialogFragment cannot have a layout"],
              "correctAnswer": "DialogFragment displays as a floating dialog",
              "explanation": "DialogFragment is a Fragment that displays as a dialog window, floating above the Activity.",
              "difficulty": "EASY"
            },
            {
              "id": "fragment_quiz_8",
              "questionText": "What is the purpose of setRetainInstance()?",
              "type": "MCQ",
              "options": ["To keep Fragment across configuration changes", "To remove Fragment from back stack", "To add Fragment to back stack", "To destroy Fragment"],
              "correctAnswer": "To keep Fragment across configuration changes",
              "explanation": "setRetainInstance(true) allows the Fragment to survive configuration changes like screen rotations.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "fragment_quiz_9",
              "questionText": "Which lifecycle callback is called when a Fragment is attached to an Activity?",
              "type": "MCQ",
              "options": ["onCreate()", "onAttach()", "onStart()", "onResume()"],
              "correctAnswer": "onAttach()",
              "explanation": "onAttach() is called when the Fragment is first attached to its host Activity.",
              "difficulty": "HARD"
            },
            {
              "id": "fragment_quiz_10",
              "questionText": "What is the purpose of FragmentTransaction?",
              "type": "MCQ",
              "options": ["To create a Fragment", "To perform operations on Fragments", "To delete a Fragment", "To style a Fragment"],
              "correctAnswer": "To perform operations on Fragments",
              "explanation": "FragmentTransaction is used to perform operations like add, remove, replace, and hide/show Fragments.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_room",
          "name": "Room Database",
          "description": "Local database persistence using Room library",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "room_theory_1",
              "questionText": "What is Room in Android?",
              "type": "THEORY",
              "correctAnswer": "Room is a persistence library that provides an abstraction layer over SQLite, allowing for more robust database access while harnessing the full power of SQLite.",
              "explanation": "Room makes it easier to work with SQLite databases by providing compile-time verification of SQL queries and reducing boilerplate code.",
              "codeExample": "@Entity\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String\n)\n\n@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAll(): List<User>\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "room_theory_2",
              "questionText": "What are the three main components of Room?",
              "type": "THEORY",
              "correctAnswer": "The three main components are: Entity (data model), DAO (Data Access Object for database operations), and Database (the main database class).",
              "explanation": "Entity represents a table in the database. DAO contains the methods for accessing the database. Database is the main access point for the database connection.",
              "codeExample": "// 1. Entity\n@Entity\ndata class User(@PrimaryKey val id: Int)\n\n// 2. DAO\n@Dao\ninterface UserDao { @Query(\"SELECT * FROM user\") fun getAll(): List<User> }\n\n// 3. Database\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "room_theory_3",
              "questionText": "What is the purpose of @Entity annotation?",
              "type": "THEORY",
              "correctAnswer": "@Entity marks a class as a table in a Room database, with each field representing a column in the table.",
              "explanation": "Room uses the @Entity annotation to create database tables from data classes. You can customize table and column names using additional annotations.",
              "codeExample": "@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    @ColumnInfo(name = \"user_name\")\n    val name: String\n)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "room_theory_4",
              "questionText": "What is the difference between @Query, @Insert, @Update, and @Delete?",
              "type": "THEORY",
              "correctAnswer": "@Query is for custom SQL queries. @Insert is for adding new records. @Update is for modifying existing records. @Delete is for removing records.",
              "explanation": "These annotations define the type of database operation in a DAO. @Query is the most flexible, allowing any SQL statement.",
              "codeExample": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user WHERE id = :id\")\n    fun getUserById(id: Int): User\n    \n    @Insert\n    fun insert(user: User)\n    \n    @Update\n    fun update(user: User)\n    \n    @Delete\n    fun delete(user: User)\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_theory_5",
              "questionText": "What is LiveData and how does it work with Room?",
              "type": "THEORY",
              "correctAnswer": "LiveData is an observable data holder that is lifecycle-aware. When used with Room, it automatically updates the UI when database data changes.",
              "explanation": "Room can return LiveData from DAO queries, which will automatically notify observers when the underlying data changes.",
              "codeExample": "@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM user\")\n    fun getAllUsers(): LiveData<List<User>>\n}\n\n// In ViewModel\nval users = userDao.getAllUsers()\n\n// In Activity\nusers.observe(this) { userList ->\n    // Update UI with new data\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_theory_6",
              "questionText": "What is the purpose of @PrimaryKey annotation?",
              "type": "THEORY",
              "correctAnswer": "@PrimaryKey marks a field as the primary key of the table, uniquely identifying each record. You can set autoGenerate to true for auto-incrementing IDs.",
              "explanation": "Every Room entity must have at least one field annotated with @PrimaryKey. This ensures each row can be uniquely identified.",
              "codeExample": "@Entity\ndata class User(\n    @PrimaryKey(autoGenerate = true)\n    val id: Int = 0,\n    val name: String\n)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "room_theory_7",
              "questionText": "What is the difference between Room and SQLite?",
              "type": "THEORY",
              "correctAnswer": "Room is an abstraction layer over SQLite that provides compile-time SQL verification, reduces boilerplate code, and integrates with other Architecture Components.",
              "explanation": "SQLite is the underlying database engine. Room provides a more convenient and type-safe way to work with SQLite databases.",
              "codeExample": "// Raw SQLite (more verbose)\nval db = SQLiteDatabase.openOrCreateDatabase(...)\nval cursor = db.rawQuery(\"SELECT * FROM user\", null)\n\n// Room (cleaner, type-safe)\n@Query(\"SELECT * FROM user\")\nfun getAll(): List<User>",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_theory_8",
              "questionText": "What is a TypeConverter in Room?",
              "type": "THEORY",
              "correctAnswer": "TypeConverter allows you to convert custom data types that Room doesn't natively support into types that Room can store in the database.",
              "explanation": "Room only supports a limited set of types. TypeConverters let you store complex objects like Date, Enums, or custom classes by converting them to supported types.",
              "codeExample": "class Converters {\n    @TypeConverter\n    fun fromDate(date: Date): Long = date.time\n    \n    @TypeConverter\n    fun toDate(timestamp: Long): Date = Date(timestamp)\n}\n\n@Database(entities = [User::class], version = 1)\n@TypeConverters(Converters::class)\nabstract class AppDatabase : RoomDatabase()",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "room_quiz_1",
              "questionText": "Which annotation is used to mark a class as a Room database table?",
              "type": "MCQ",
              "options": ["@Table", "@Entity", "@Database", "@Model"],
              "correctAnswer": "@Entity",
              "explanation": "@Entity marks a class as a table in the Room database.",
              "difficulty": "EASY"
            },
            {
              "id": "room_quiz_2",
              "questionText": "What annotation is used to define database operations?",
              "type": "MCQ",
              "options": ["@Operations", "@DAO", "@Dao", "@DatabaseOps"],
              "correctAnswer": "@Dao",
              "explanation": "@Dao marks an interface or abstract class as a Data Access Object for Room.",
              "difficulty": "EASY"
            },
            {
              "id": "room_quiz_3",
              "questionText": "Which method is used to execute custom SQL queries in Room?",
              "type": "MCQ",
              "options": ["@Execute", "@Query", "@Run", "@Sql"],
              "correctAnswer": "@Query",
              "explanation": "@Query is used to execute custom SQL statements in Room DAOs.",
              "difficulty": "EASY"
            },
            {
              "id": "room_quiz_4",
              "questionText": "What is the purpose of @ColumnInfo annotation?",
              "type": "MCQ",
              "options": ["To add column information", "To specify column name and attributes", "To create a new column", "To delete a column"],
              "correctAnswer": "To specify column name and attributes",
              "explanation": "@ColumnInfo allows you to customize the column name and other attributes in the database table.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_quiz_5",
              "questionText": "How do you handle database schema changes in Room?",
              "type": "MCQ",
              "options": ["Delete the app", "Use Migration", "Ignore the changes", "Reinstall the app"],
              "correctAnswer": "Use Migration",
              "explanation": "Room provides Migration classes to handle schema changes between database versions.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_quiz_6",
              "questionText": "What is the purpose of @Ignore annotation?",
              "type": "MCQ",
              "options": ["To ignore errors", "To exclude a field from the database", "To ignore null values", "To ignore primary key"],
              "correctAnswer": "To exclude a field from the database",
              "explanation": "@Ignore tells Room to exclude a field from the database table.",
              "difficulty": "EASY"
            },
            {
              "id": "room_quiz_7",
              "questionText": "Which annotation is used to create relationships between tables?",
              "type": "MCQ",
              "options": ["@Relation", "@ForeignKey", "@Join", "@Connect"],
              "correctAnswer": "@Relation",
              "explanation": "@Relation is used to define relationships between entities in Room.",
              "difficulty": "HARD"
            },
            {
              "id": "room_quiz_8",
              "questionText": "What is the difference between @Insert(onConflict = REPLACE) and @Insert?",
              "type": "MCQ",
              "options": ["No difference", "REPLACE replaces existing rows, normal insert fails on conflict", "REPLACE fails on conflict, normal insert replaces", "Both replace existing rows"],
              "correctAnswer": "REPLACE replaces existing rows, normal insert fails on conflict",
              "explanation": "onConflict = REPLACE will replace existing rows if there's a conflict, while default behavior is to fail.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "room_quiz_9",
              "questionText": "What is the purpose of RoomDatabase.Builder?",
              "type": "MCQ",
              "options": ["To build queries", "To create and configure the database instance", "To build tables", "To build relationships"],
              "correctAnswer": "To create and configure the database instance",
              "explanation": "RoomDatabase.Builder is used to create and configure the database instance with options like database name and context.",
              "difficulty": "EASY"
            },
            {
              "id": "room_quiz_10",
              "questionText": "How do you make Room queries return Flow or LiveData?",
              "type": "MCQ",
              "options": ["By using @Flow annotation", "By returning Flow or LiveData types from DAO methods", "By using @Observable annotation", "Room doesn't support Flow or LiveData"],
              "correctAnswer": "By returning Flow or LiveData types from DAO methods",
              "explanation": "Room supports returning Flow, LiveData, and RxJava types from DAO queries for reactive data observation.",
              "difficulty": "MEDIUM"
            }
          ]
        },
        {
          "id": "android_coroutines",
          "name": "Coroutines & Concurrency",
          "description": "Asynchronous programming with Kotlin Coroutines",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "coroutines_theory_1",
              "questionText": "What are Coroutines in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "Coroutines are a way to write asynchronous, non-blocking code that looks synchronous, making it easier to handle long-running tasks like network operations.",
              "explanation": "Coroutines allow you to write asynchronous code in a sequential style, avoiding callback hell and making code more readable and maintainable.",
              "codeExample": "// Synchronous-looking async code\nsuspend fun fetchData(): String {\n    return withContext(Dispatchers.IO) {\n        // Network operation\n        \"Data\"\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_theory_2",
              "questionText": "What is the 'suspend' keyword?",
              "type": "THEORY",
              "correctAnswer": "The 'suspend' keyword marks a function as capable of being paused and resumed without blocking the thread, allowing it to be called from coroutines.",
              "explanation": "Suspend functions can only be called from other suspend functions or coroutine scopes. They can pause execution without blocking the thread.",
              "codeExample": "suspend fun fetchData(): String {\n    delay(1000) // Non-blocking delay\n    return \"Data\"\n}\n\n// Can only be called from coroutine\nGlobalScope.launch {\n    val data = fetchData()\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_theory_3",
              "questionText": "What are the different Coroutine Dispatchers?",
              "type": "THEORY",
              "correctAnswer": "The main dispatchers are: Dispatchers.Main (UI thread), Dispatchers.IO (I/O operations), Dispatchers.Default (CPU-intensive tasks), and Dispatchers.Unconfined (no specific dispatcher).",
              "explanation": "Dispatchers determine which thread or thread pool the coroutine runs on. Main is for UI, IO for network/database, Default for computations.",
              "codeExample": "// Main thread - UI operations\nwithContext(Dispatchers.Main) {\n    textView.text = \"Updated\"\n}\n\n// IO thread - network/database\nwithContext(Dispatchers.IO) {\n    val data = networkCall()\n}\n\n// Default - CPU intensive\nwithContext(Dispatchers.Default) {\n    val result = heavyComputation()\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_theory_4",
              "questionText": "What is the difference between launch and async?",
              "type": "THEORY",
              "correctAnswer": "launch is used for fire-and-forget tasks where you don't need a result. async is used when you need to return a result and can be used with await.",
              "explanation": "launch starts a coroutine that doesn't return a value. async starts a coroutine that returns a Deferred result that can be awaited.",
              "codeExample": "// launch - fire and forget\nlaunch {\n    doSomething()\n}\n\n// async - returns result\nval deferred = async {\n    computeResult()\n}\nval result = deferred.await()",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_theory_5",
              "questionText": "What is viewModelScope?",
              "type": "THEORY",
              "correctAnswer": "viewModelScope is a coroutine scope tied to a ViewModel's lifecycle. All coroutines launched in this scope are automatically cancelled when the ViewModel is cleared.",
              "explanation": "viewModelScope helps avoid memory leaks by automatically cancelling coroutines when the ViewModel is no longer needed.",
              "codeExample": "class MyViewModel : ViewModel() {\n    init {\n        viewModelScope.launch {\n            // Automatically cancelled when ViewModel is cleared\n            val data = repository.fetchData()\n            _uiState.value = data\n        }\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_theory_6",
              "questionText": "What is the purpose of withContext?",
              "type": "THEORY",
              "correctAnswer": "withContext switches the coroutine's context to run in a different dispatcher, then returns to the original context when complete. It's suspending and blocks until done.",
              "explanation": "withContext is useful for switching between dispatchers, like moving from Main to IO for network operations, then back to Main to update UI.",
              "codeExample": "suspend fun updateUI() {\n    // Switch to IO for network call\n    val data = withContext(Dispatchers.IO) {\n        networkService.fetchData()\n    }\n    // Back on Main thread\n    textView.text = data\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_theory_7",
              "questionText": "What is the difference between runBlocking and coroutineScope?",
              "type": "THEORY",
              "correctAnswer": "runBlocking blocks the current thread until all coroutines complete. coroutineScope suspends the current coroutine without blocking the thread.",
              "explanation": "runBlocking is mainly used in tests and main functions. coroutineScope is used within other coroutines to structure concurrent code.",
              "codeExample": "// Blocks the thread\nrunBlocking {\n    launch { delay(1000) }\n}\n\n// Suspends without blocking\nsuspend fun myFunction() {\n    coroutineScope {\n        launch { delay(1000) }\n    }\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "coroutines_theory_8",
              "questionText": "What is Structured Concurrency?",
              "type": "THEORY",
              "correctAnswer": "Structured Concurrency is a programming paradigm where coroutines have a defined scope and lifecycle, ensuring they don't leak and are properly cancelled when no longer needed.",
              "explanation": "In structured concurrency, coroutines are launched in a scope that tracks them. When the scope is cancelled, all child coroutines are automatically cancelled.",
              "codeExample": "coroutineScope {\n    // All coroutines here are tracked\n    launch { task1() }\n    launch { task2() }\n    // Both are cancelled if this scope is cancelled\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "coroutines_quiz_1",
              "questionText": "Which keyword is used to mark a function as suspendable?",
              "type": "MCQ",
              "options": ["async", "await", "suspend", "delay"],
              "correctAnswer": "suspend",
              "explanation": "The suspend keyword marks a function that can be paused and resumed without blocking.",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_quiz_2",
              "questionText": "Which dispatcher should be used for UI operations?",
              "type": "MCQ",
              "options": ["Dispatchers.IO", "Dispatchers.Main", "Dispatchers.Default", "Dispatchers.Unconfined"],
              "correctAnswer": "Dispatchers.Main",
              "explanation": "Dispatchers.Main runs coroutines on the main UI thread.",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_quiz_3",
              "questionText": "What is the purpose of the delay() function?",
              "type": "MCQ",
              "options": ["To block the thread", "To pause the coroutine without blocking", "To cancel the coroutine", "To start a new coroutine"],
              "correctAnswer": "To pause the coroutine without blocking",
              "explanation": "delay() suspends the coroutine for a specified time without blocking the thread.",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_quiz_4",
              "questionText": "Which function is used to get the result of an async coroutine?",
              "type": "MCQ",
              "options": ["get()", "result()", "await()", "join()"],
              "correctAnswer": "await()",
              "explanation": "await() is called on a Deferred object to get the result of an async coroutine.",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_quiz_5",
              "questionText": "What is the purpose of lifecycleScope?",
              "type": "MCQ",
              "options": ["To launch coroutines in ViewModel", "To launch coroutines tied to Activity/Fragment lifecycle", "To launch coroutines globally", "To launch coroutines in Service"],
              "correctAnswer": "To launch coroutines tied to Activity/Fragment lifecycle",
              "explanation": "lifecycleScope launches coroutines that are automatically cancelled when the Activity or Fragment is destroyed.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_quiz_6",
              "questionText": "What happens when a coroutine is cancelled?",
              "type": "MCQ",
              "options": ["It continues running", "It throws CancellationException", "It blocks the thread", "Nothing happens"],
              "correctAnswer": "It throws CancellationException",
              "explanation": "When a coroutine is cancelled, it throws CancellationException which can be caught for cleanup.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_quiz_7",
              "questionText": "Which dispatcher is best for network operations?",
              "type": "MCQ",
              "options": ["Dispatchers.Main", "Dispatchers.IO", "Dispatchers.Default", "Dispatchers.Unconfined"],
              "correctAnswer": "Dispatchers.IO",
              "explanation": "Dispatchers.IO is optimized for I/O operations like network calls and file access.",
              "difficulty": "EASY"
            },
            {
              "id": "coroutines_quiz_8",
              "questionText": "What is the difference between Job and Deferred?",
              "type": "MCQ",
              "options": ["No difference", "Job has no result, Deferred has a result", "Deferred has no result, Job has a result", "Both have results"],
              "correctAnswer": "Job has no result, Deferred has a result",
              "explanation": "Job represents a coroutine without a result. Deferred is a Job that has a result.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "coroutines_quiz_9",
              "questionText": "What is the purpose of SupervisorJob?",
              "type": "MCQ",
              "options": ["To supervise all coroutines", "To prevent child failures from cancelling parent", "To cancel all coroutines", "To block the thread"],
              "correctAnswer": "To prevent child failures from cancelling parent",
              "explanation": "SupervisorJob allows child coroutines to fail without cancelling their parent or siblings.",
              "difficulty": "HARD"
            },
            {
              "id": "coroutines_quiz_10",
              "questionText": "Which function is used to run multiple coroutines concurrently and wait for all to complete?",
              "type": "MCQ",
              "options": ["launch()", "async()", "awaitAll()", "coroutineScope()"],
              "correctAnswer": "awaitAll()",
              "explanation": "awaitAll() waits for all Deferred coroutines to complete and returns their results.",
              "difficulty": "MEDIUM"
            }
          ]
        },
        {
          "id": "android_networking",
          "name": "Networking & Retrofit",
          "description": "Network operations and API integration",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "networking_theory_1",
              "questionText": "What is Retrofit in Android?",
              "type": "THEORY",
              "correctAnswer": "Retrofit is a type-safe HTTP client for Android and Java that makes it easy to consume REST APIs by converting HTTP APIs into Java interfaces.",
              "explanation": "Retrofit handles the network request/response conversion, URL handling, and provides a clean API for making network calls.",
              "codeExample": "interface ApiService {\n    @GET(\"users/{id}\")\n    suspend fun getUser(@Path(\"id\") id: Int): Response<User>\n}\n\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com/\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "networking_theory_2",
              "questionText": "What are the main components of Retrofit?",
              "type": "THEORY",
              "correctAnswer": "The main components are: Retrofit instance (configured client), API interface (defines endpoints), Converters (JSON parsing), and Call adapters (async handling).",
              "explanation": "Retrofit uses these components together to provide a complete networking solution. The API interface defines the endpoints, converters handle serialization.",
              "codeExample": "// 1. Retrofit instance\nval retrofit = Retrofit.Builder()\n    .baseUrl(BASE_URL)\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()\n\n// 2. API interface\ninterface Api {\n    @GET(\"users\")\n    suspend fun getUsers(): List<User>\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_theory_3",
              "questionText": "What is the difference between @GET, @POST, @PUT, and @DELETE?",
              "type": "THEORY",
              "correctAnswer": "@GET is for retrieving data. @POST is for creating new data. @PUT is for updating existing data. @DELETE is for removing data.",
              "explanation": "These annotations map to HTTP methods and define the type of operation being performed on the API endpoint.",
              "codeExample": "@GET(\"users\")\nsuspend fun getUsers(): List<User>\n\n@POST(\"users\")\nsuspend fun createUser(@Body user: User): User\n\n@PUT(\"users/{id}\")\nsuspend fun updateUser(@Path(\"id\") id: Int, @Body user: User): User\n\n@DELETE(\"users/{id}\")\nsuspend fun deleteUser(@Path(\"id\") id: Int)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "networking_theory_4",
              "questionText": "What is the purpose of @Path annotation?",
              "type": "THEORY",
              "correctAnswer": "@Path is used to replace placeholders in the URL path with dynamic values from method parameters.",
              "explanation": "@Path allows you to create dynamic URLs where parts of the path are determined at runtime.",
              "codeExample": "@GET(\"users/{id}\")\nsuspend fun getUser(@Path(\"id\") userId: Int): User\n\n// Call: getUser(123)\n// URL: https://api.example.com/users/123",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "networking_theory_5",
              "questionText": "What is the purpose of @Query annotation?",
              "type": "THEORY",
              "correctAnswer": "@Query is used to add query parameters to the URL, typically for filtering, searching, or pagination.",
              "explanation": "@Query automatically URL-encodes parameters and appends them to the URL as query string parameters.",
              "codeExample": "@GET(\"users\")\nsuspend fun getUsers(\n    @Query(\"page\") page: Int,\n    @Query(\"limit\") limit: Int\n): List<User>\n\n// Call: getUsers(page=1, limit=10)\n// URL: https://api.example.com/users?page=1&limit=10",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "networking_theory_6",
              "questionText": "What is the purpose of @Body annotation?",
              "type": "THEORY",
              "correctAnswer": "@Body is used to send a request body (typically JSON) in POST, PUT, and PATCH requests.",
              "explanation": "@Body tells Retrofit to serialize the parameter as the request body using the configured converter factory.",
              "codeExample": "@POST(\"users\")\nsuspend fun createUser(@Body user: User): User\n\n// The user object will be serialized to JSON\n// and sent as the request body",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_theory_7",
              "questionText": "What is OkHttp Interceptor?",
              "type": "THEORY",
              "correctAnswer": "OkHttp Interceptor is a mechanism to observe, modify, and potentially retry requests and responses, useful for logging, authentication, and adding headers.",
              "explanation": "Interceptors can be used to add authentication headers, log requests/responses, modify URLs, or handle errors globally.",
              "codeExample": "class AuthInterceptor(private val token: String) : Interceptor {\n    override fun intercept(chain: Interceptor.Chain): Response {\n        val originalRequest = chain.request()\n        val authenticatedRequest = originalRequest.newBuilder()\n            .header(\"Authorization\", \"Bearer $token\")\n            .build()\n        return chain.proceed(authenticatedRequest)\n    }\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "networking_theory_8",
              "questionText": "What is the difference between synchronous and asynchronous Retrofit calls?",
              "type": "THEORY",
              "correctAnswer": "Synchronous calls block the thread until the response is received. Asynchronous calls use callbacks or coroutines and don't block the thread.",
              "explanation": "In modern Android development, you should use suspend functions with coroutines for asynchronous calls to avoid blocking the main thread.",
              "codeExample": "// Synchronous (blocks thread)\nval response = apiService.getUser(123).execute()\n\n// Asynchronous with coroutines (recommended)\nval user = apiService.getUser(123)\n\n// Asynchronous with callback (legacy)\napiService.getUser(123).enqueue(object : Callback<User> {\n    override fun onResponse(call: Call<User>, response: Response<User>) {}\n    override fun onFailure(call: Call<User>, t: Throwable) {}\n})",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "networking_quiz_1",
              "questionText": "Which library is commonly used with Retrofit for JSON parsing?",
              "type": "MCQ",
              "options": ["Jackson", "Gson", "Moshi", "All of the above"],
              "correctAnswer": "All of the above",
              "explanation": "Retrofit supports multiple JSON parsing libraries including Gson, Moshi, and Jackson through converter factories.",
              "difficulty": "EASY"
            },
            {
              "id": "networking_quiz_2",
              "questionText": "What annotation is used to send data in the request body?",
              "type": "MCQ",
              "options": ["@Query", "@Path", "@Body", "@Header"],
              "correctAnswer": "@Body",
              "explanation": "@Body is used to send data as the request body in POST, PUT, and PATCH requests.",
              "difficulty": "EASY"
            },
            {
              "id": "networking_quiz_3",
              "questionText": "What is the purpose of baseUrl in Retrofit?",
              "type": "MCQ",
              "options": ["To specify the API endpoint", "To specify the base URL for all requests", "To specify authentication", "To specify timeout"],
              "correctAnswer": "To specify the base URL for all requests",
              "explanation": "baseUrl is the starting URL that all API endpoints are relative to.",
              "difficulty": "EASY"
            },
            {
              "id": "networking_quiz_4",
              "questionText": "Which annotation is used to add headers to a request?",
              "type": "MCQ",
              "options": ["@Header", "@Headers", "Both @Header and @Headers", "Neither"],
              "correctAnswer": "Both @Header and @Headers",
              "explanation": "@Header adds a single header, while @Headers can add multiple headers at once.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_quiz_5",
              "questionText": "What is the purpose of ConverterFactory in Retrofit?",
              "type": "MCQ",
              "options": ["To convert URLs", "To serialize/deserialize request and response bodies", "To handle errors", "To add authentication"],
              "correctAnswer": "To serialize/deserialize request and response bodies",
              "explanation": "ConverterFactory handles the conversion between Java objects and HTTP request/response bodies.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_quiz_6",
              "questionText": "What does Response object contain in Retrofit?",
              "type": "MCQ",
              "options": ["Only the body", "Only the status code", "Both body, status code, headers, and error information", "Only headers"],
              "correctAnswer": "Both body, status code, headers, and error information",
              "explanation": "Response contains the response body, status code, headers, and information about whether the request was successful.",
              "difficulty": "EASY"
            },
            {
              "id": "networking_quiz_7",
              "questionText": "How do you handle errors in Retrofit with coroutines?",
              "type": "MCQ",
              "options": ["Using try-catch", "Using onError callback", "Using error interceptor", "Errors are not handled"],
              "correctAnswer": "Using try-catch",
              "explanation": "With coroutines, you wrap Retrofit calls in try-catch blocks to handle exceptions like network errors or HTTP errors.",
              "difficulty": "EASY"
            },
            {
              "id": "networking_quiz_8",
              "questionText": "What is the purpose of @Multipart annotation?",
              "type": "MCQ",
              "options": ["To send multiple requests", "To send multipart form data like file uploads", "To send multiple headers", "To send multiple URLs"],
              "correctAnswer": "To send multipart form data like file uploads",
              "explanation": "@Multipart is used for requests that have multipart form data, typically for file uploads.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_quiz_9",
              "questionText": "What is the difference between @Field and @Query?",
              "type": "MCQ",
              "options": ["No difference", "@Field is for form-encoded data, @Query is for URL parameters", "@Query is for form-encoded data, @Field is for URL parameters", "Both are the same"],
              "correctAnswer": "@Field is for form-encoded data, @Query is for URL parameters",
              "explanation": "@Field is used with @FormUrlEncoded for form data. @Query adds parameters to the URL query string.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "networking_quiz_10",
              "questionText": "What is the purpose of OkHttp in Retrofit?",
              "type": "MCQ",
              "options": ["To parse JSON", "To handle HTTP connections", "To create UI", "To store data"],
              "correctAnswer": "To handle HTTP connections",
              "explanation": "Retrofit uses OkHttp under the hood to handle HTTP connections and network operations.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_permissions",
          "name": "Permissions & Security",
          "description": "Runtime permissions and app security",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "permissions_theory_1",
              "questionText": "What are runtime permissions in Android?",
              "type": "THEORY",
              "correctAnswer": "Runtime permissions are permissions that apps must request from the user at runtime, rather than being granted automatically at install time.",
              "explanation": "Introduced in Android 6.0 (API 23), runtime permissions give users more control over what apps can access, improving privacy and security.",
              "codeExample": "// Check permission\nif (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {\n    // Request permission\n    ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), CAMERA_REQUEST_CODE)\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_theory_2",
              "questionText": "What is the difference between normal and dangerous permissions?",
              "type": "THEORY",
              "correctAnswer": "Normal permissions are granted automatically at install time. Dangerous permissions require runtime user approval and can affect user privacy.",
              "explanation": "Normal permissions (like INTERNET) pose minimal risk. Dangerous permissions (like CAMERA, LOCATION) can access sensitive data and require explicit user consent.",
              "codeExample": "// Normal permission - granted automatically\n<uses-permission android:name=\"android.permission.INTERNET\" />\n\n// Dangerous permission - requires runtime request\n<uses-permission android:name=\"android.permission.CAMERA\" />",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_theory_3",
              "questionText": "How do you handle permission request results?",
              "type": "THEORY",
              "correctAnswer": "You override onRequestPermissionsResult() callback to handle the user's decision, checking if permissions were granted or denied.",
              "explanation": "This callback receives the request code, permissions array, and grantResults array indicating which permissions were granted.",
              "codeExample": "override fun onRequestPermissionsResult(\n    requestCode: Int,\n    permissions: Array<out String>,\n    grantResults: IntArray\n) {\n    super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n    if (requestCode == CAMERA_REQUEST_CODE) {\n        if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n            // Permission granted\n        } else {\n            // Permission denied\n        }\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "permissions_theory_4",
              "questionText": "What is shouldShowRequestPermissionRationale()?",
              "type": "THEORY",
              "correctAnswer": "This method returns true if the user has previously denied the permission and selected 'Don't ask again', indicating you should show an explanation before requesting again.",
              "explanation": "Use this method to determine if you should show a rationale dialog explaining why the permission is needed before requesting it again.",
              "codeExample": "if (ActivityCompat.shouldShowRequestPermissionRationale(this, Manifest.permission.CAMERA)) {\n    // Show explanation dialog\n    AlertDialog.Builder(this)\n        .setTitle(\"Camera Permission Needed\")\n        .setMessage(\"This app needs camera access to take photos\")\n        .setPositiveButton(\"OK\") { _, _ ->\n            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), CAMERA_REQUEST_CODE)\n        }\n        .show()\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "permissions_theory_5",
              "questionText": "What are the best practices for requesting permissions?",
              "type": "THEORY",
              "correctAnswer": "Best practices include: requesting permissions when needed (not at startup), explaining why the permission is needed, handling denial gracefully, and providing fallback functionality.",
              "explanation": "Don't request all permissions at app launch. Request them contextually when the feature is needed. Always explain why and handle denials appropriately.",
              "codeExample": "// Request permission when feature is needed\nfun takePhoto() {\n    if (hasCameraPermission()) {\n        // Open camera\n    } else {\n        // Request permission with explanation\n        requestCameraPermission()\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "permissions_theory_6",
              "questionText": "What is the purpose of AndroidManifest.xml permissions section?",
              "type": "THEORY",
              "correctAnswer": "The permissions section in AndroidManifest.xml declares all permissions the app needs, including both normal and dangerous permissions.",
              "explanation": "Even runtime permissions must be declared in the manifest. The manifest serves as documentation and is required for the app to function properly.",
              "codeExample": "<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n</manifest>",
              "imageUrl": "",
              "difficulty": "EASY"
            }
          ],
          "quizQuestions": [
            {
              "id": "permissions_quiz_1",
              "questionText": "When were runtime permissions introduced in Android?",
              "type": "MCQ",
              "options": ["Android 4.0 (API 14)", "Android 5.0 (API 21)", "Android 6.0 (API 23)", "Android 7.0 (API 24)"],
              "correctAnswer": "Android 6.0 (API 23)",
              "explanation": "Runtime permissions were introduced in Android 6.0 (Marshmallow, API 23).",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_2",
              "questionText": "Which method is used to check if a permission is granted?",
              "type": "MCQ",
              "options": ["checkPermission()", "checkSelfPermission()", "hasPermission()", "isPermissionGranted()"],
              "correctAnswer": "checkSelfPermission()",
              "explanation": "ContextCompat.checkSelfPermission() checks if a permission is granted.",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_3",
              "questionText": "What is the result value when a permission is granted?",
              "type": "MCQ",
              "options": ["PackageManager.PERMISSION_GRANTED", "PackageManager.PERMISSION_OK", "PackageManager.PERMISSION_ALLOWED", "PackageManager.PERMISSION_YES"],
              "correctAnswer": "PackageManager.PERMISSION_GRANTED",
              "explanation": "PackageManager.PERMISSION_GRANTED indicates the permission was granted.",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_4",
              "questionText": "Which callback handles permission request results?",
              "type": "MCQ",
              "options": ["onPermissionResult()", "onRequestPermissionsResult()", "onPermissionGranted()", "handlePermissionResult()"],
              "correctAnswer": "onRequestPermissionsResult()",
              "explanation": "onRequestPermissionsResult() is called when the user responds to a permission request.",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_5",
              "questionText": "What does shouldShowRequestPermissionRationale() return when user selected 'Don't ask again'?",
              "type": "MCQ",
              "options": ["true", "false", "null", "error"],
              "correctAnswer": "true",
              "explanation": "It returns true when the user has denied the permission and selected 'Don't ask again'.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "permissions_quiz_6",
              "questionText": "Which of these is a dangerous permission?",
              "type": "MCQ",
              "options": ["INTERNET", "CAMERA", "VIBRATE", "WAKE_LOCK"],
              "correctAnswer": "CAMERA",
              "explanation": "CAMERA is a dangerous permission that requires runtime user approval.",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_7",
              "questionText": "What should you do if a user denies a permission?",
              "type": "MCQ",
              "options": ["Force the permission", "Show an explanation and provide fallback", "Exit the app", "Request again immediately"],
              "correctAnswer": "Show an explanation and provide fallback",
              "explanation": "You should explain why the permission is needed and provide fallback functionality if the user denies it.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "permissions_quiz_8",
              "questionText": "Where must all permissions be declared?",
              "type": "MCQ",
              "options": ["In the code", "In AndroidManifest.xml", "In build.gradle", "In strings.xml"],
              "correctAnswer": "In AndroidManifest.xml",
              "explanation": "All permissions must be declared in AndroidManifest.xml using <uses-permission> tags.",
              "difficulty": "EASY"
            },
            {
              "id": "permissions_quiz_9",
              "questionText": "What is the purpose of permission groups?",
              "type": "MCQ",
              "options": ["To group permissions by category", "Granting one permission grants all in the group", "To organize permissions in manifest", "To create custom permissions"],
              "correctAnswer": "Granting one permission grants all in the group",
              "explanation": "Permission groups allow granting one permission to automatically grant related permissions in the same group.",
              "difficulty": "HARD"
            },
            {
              "id": "permissions_quiz_10",
              "questionText": "Which method is used to request permissions?",
              "type": "MCQ",
              "options": ["requestPermissions()", "ActivityCompat.requestPermissions()", "askForPermissions()", "grantPermissions()"],
              "correctAnswer": "ActivityCompat.requestPermissions()",
              "explanation": "ActivityCompat.requestPermissions() is used to request runtime permissions from the user.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_viewbinding",
          "name": "View Binding",
          "description": "Type-safe view access with View Binding",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "viewbinding_theory_1",
              "questionText": "What is View Binding in Android?",
              "type": "THEORY",
              "correctAnswer": "View Binding is a feature that allows you to write code that interacts with views more easily and safely by generating a binding class for each XML layout.",
              "explanation": "View Binding eliminates the need for findViewById() and provides type-safe access to views, reducing runtime errors and improving code safety.",
              "codeExample": "// In build.gradle\nandroid {\n    viewBinding {\n        enabled = true\n    }\n}\n\n// In Activity\nprivate lateinit var binding: ActivityMainBinding\n\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    binding = ActivityMainBinding.inflate(layoutInflater)\n    setContentView(binding.root)\n    binding.textView.text = \"Hello\"\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_theory_2",
              "questionText": "What is the difference between View Binding and findViewById?",
              "type": "THEORY",
              "correctAnswer": "View Binding generates type-safe binding classes at compile time, while findViewById() is runtime-based and can cause null pointer exceptions and type mismatches.",
              "explanation": "View Binding provides compile-time safety, better performance, and null safety. findViewById() is error-prone and requires casting.",
              "codeExample": "// findViewById - error-prone\nval textView = findViewById<TextView>(R.id.textView)\ntextView.text = \"Hello\"\n\n// View Binding - type-safe\nbinding.textView.text = \"Hello\"",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_theory_3",
              "questionText": "How do you use View Binding in Fragments?",
              "type": "THEORY",
              "correctAnswer": "In Fragments, you inflate the binding in onCreateView() using the inflate() method with the fragment's layoutInflater, and return binding.root.",
              "explanation": "Fragments require special handling for View Binding to ensure proper lifecycle management and view inflation.",
              "codeExample": "private var _binding: FragmentMyBinding? = null\nprivate val binding get() = _binding!!\n\noverride fun onCreateView(\n    inflater: LayoutInflater,\n    container: ViewGroup?,\n    savedInstanceState: Bundle?\n): View? {\n    _binding = FragmentMyBinding.inflate(inflater, container, false)\n    return binding.root\n}\n\noverride fun onDestroyView() {\n    super.onDestroyView()\n    _binding = null\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "viewbinding_theory_4",
              "questionText": "What is the difference between View Binding and Data Binding?",
              "type": "THEORY",
              "correctAnswer": "View Binding is for view access only. Data Binding includes View Binding features plus the ability to bind UI components to data sources in XML layouts.",
              "explanation": "Data Binding is more powerful but has a steeper learning curve and larger build overhead. View Binding is simpler and lighter for just view access.",
              "codeExample": "// View Binding - simple view access\nbinding.textView.text = data.name\n\n// Data Binding - can bind in XML\n<TextView\n    android:text=\"@{user.name}\" />",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "viewbinding_theory_5",
              "questionText": "How do you enable View Binding in a project?",
              "type": "THEORY",
              "correctAnswer": "You enable View Binding in the build.gradle file by adding the viewBinding block inside the android block and setting enabled to true.",
              "explanation": "View Binding is enabled per module in the build.gradle file. Once enabled, it generates binding classes for all XML layouts in that module.",
              "codeExample": "android {\n    compileSdk 34\n    \n    defaultConfig {\n        applicationId \"com.example.app\"\n        // ...\n    }\n    \n    buildFeatures {\n        viewBinding = true\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            }
          ],
          "quizQuestions": [
            {
              "id": "viewbinding_quiz_1",
              "questionText": "What is the main advantage of View Binding over findViewById?",
              "type": "MCQ",
              "options": ["Faster performance", "Type safety and null safety", "Smaller APK size", "Better UI design"],
              "correctAnswer": "Type safety and null safety",
              "explanation": "View Binding provides compile-time type safety and null safety, preventing runtime errors.",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_2",
              "questionText": "How do you access a view with View Binding?",
              "type": "MCQ",
              "options": ["findViewById(R.id.view)", "binding.view", "R.id.view", "getView(R.id.view)"],
              "correctAnswer": "binding.view",
              "explanation": "With View Binding, you access views directly through the binding object without IDs.",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_3",
              "questionText": "What method is used to create a binding instance?",
              "type": "MCQ",
              "options": ["create()", "newInstance()", "inflate()", "bind()"],
              "correctAnswer": "inflate()",
              "explanation": "The inflate() method is used to create a binding instance from a layout.",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_4",
              "questionText": "What should you do with the binding in Fragment's onDestroyView()?",
              "type": "MCQ",
              "options": ["Keep it for later use", "Set it to null to avoid memory leaks", "Recreate it", "Nothing"],
              "correctAnswer": "Set it to null to avoid memory leaks",
              "explanation": "In Fragments, you should set the binding to null in onDestroyView() to avoid memory leaks.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "viewbinding_quiz_5",
              "questionText": "Where do you enable View Binding?",
              "type": "MCQ",
              "options": ["In AndroidManifest.xml", "In build.gradle", "In the Activity", "In the layout XML"],
              "correctAnswer": "In build.gradle",
              "explanation": "View Binding is enabled in the module's build.gradle file.",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_6",
              "questionText": "What is the naming convention for generated binding classes?",
              "type": "MCQ",
              "options": ["LayoutNameBinding", "BindingLayoutName", "LayoutBinding", "ViewBindingLayoutName"],
              "correctAnswer": "LayoutNameBinding",
              "explanation": "Binding classes are named by converting the layout name to Pascal case and adding 'Binding' suffix.",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_7",
              "questionText": "Can View Binding be used with include tags?",
              "type": "MCQ",
              "options": ["No", "Yes, with an ID on the include tag", "Only with merge tags", "Yes, automatically"],
              "correctAnswer": "Yes, with an ID on the include tag",
              "explanation": "To use View Binding with include tags, you must add an ID to the include tag in the parent layout.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "viewbinding_quiz_8",
              "questionText": "What does binding.root represent?",
              "type": "MCQ",
              "options": ["The root view of the layout", "The first child view", "The activity context", "The binding object"],
              "correctAnswer": "The root view of the layout",
              "explanation": "binding.root is the root view of the inflated layout, typically passed to setContentView().",
              "difficulty": "EASY"
            },
            {
              "id": "viewbinding_quiz_9",
              "questionText": "Does View Binding support two-way data binding?",
              "type": "MCQ",
              "options": ["Yes", "No", "Only with additional setup", "Only in Compose"],
              "correctAnswer": "No",
              "explanation": "View Binding does not support two-way data binding. For that, you need Data Binding.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "viewbinding_quiz_10",
              "questionText": "What is the build overhead of View Binding compared to findViewById?",
              "type": "MCQ",
              "options": ["Much higher", "Slightly higher", "Same", "Lower"],
              "correctAnswer": "Slightly higher",
              "explanation": "View Binding has a slight build overhead due to code generation, but runtime performance is better.",
              "difficulty": "HARD"
            }
          ]
        },
        {
          "id": "android_navigation",
          "name": "Navigation Component",
          "description": "Navigation architecture and implementation",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "navigation_theory_1",
              "questionText": "What is the Navigation Component in Android?",
              "type": "THEORY",
              "correctAnswer": "The Navigation Component is a framework that simplifies implementing navigation in Android apps, providing a visual editor for navigation graphs and handling back stack management.",
              "explanation": "Navigation Component provides a consistent way to handle navigation, including handling the back button, deep linking, and passing data between destinations.",
              "codeExample": "// In build.gradle\ndependencies {\n    def nav_version = \"2.7.0\"\n    implementation \"androidx.navigation:navigation-fragment:$nav_version\"\n    implementation \"androidx.navigation:navigation-ui:$nav_version\"\n}\n\n// In Activity\nval navController = findNavController(R.id.nav_host_fragment)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_theory_2",
              "questionText": "What is a NavHost in Navigation Component?",
              "type": "THEORY",
              "correctAnswer": "A NavHost is an empty container that displays destinations from your navigation graph. It's where fragments are swapped in and out as users navigate.",
              "explanation": "NavHostFragment is the default implementation that manages the display of destinations and handles the navigation back stack.",
              "codeExample": "<fragment\n    android:id=\"@+id/nav_host_fragment\"\n    android:name=\"androidx.navigation.fragment.NavHostFragment\"\n    app:navGraph=\"@navigation/nav_graph\" />",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_theory_3",
              "questionText": "How do you navigate between destinations using Navigation Component?",
              "type": "THEORY",
              "correctAnswer": "You use the NavController to navigate between destinations by calling methods like navigate() with the destination ID or action ID.",
              "explanation": "NavController manages navigation within a NavHost. You can navigate using destination IDs, action IDs, or deep links.",
              "codeExample": "// Navigate using destination ID\nfindNavController().navigate(R.id.destinationFragment)\n\n// Navigate using action\nfindNavController().navigate(R.id.action_home_to_profile)\n\n// Navigate with arguments\nval bundle = bundleOf(\"userId\" to 123)\nfindNavController().navigate(R.id.profileFragment, bundle)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_theory_4",
              "questionText": "How do you pass data between destinations?",
              "type": "THEORY",
              "correctAnswer": "You can pass data between destinations using Bundle arguments, Safe Args (type-safe arguments), or by sharing data through a ViewModel.",
              "explanation": "Safe Args is the recommended approach as it provides type safety and eliminates the need for string keys when passing arguments.",
              "codeExample": "// Using Safe Args\nval action = HomeFragmentDirections.actionHomeToProfile(userId = 123)\nfindNavController().navigate(action)\n\n// Receiving arguments\nval args: ProfileFragmentArgs by navArgs()\nval userId = args.userId",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_theory_5",
              "questionText": "What is Safe Args in Navigation Component?",
              "type": "THEORY",
              "correctAnswer": "Safe Args is a Gradle plugin that generates type-safe classes for navigating between destinations and passing arguments, eliminating the need for string keys.",
              "explanation": "Safe Args generates classes for each destination with type-safe argument passing, reducing runtime errors and improving code safety.",
              "codeExample": "// In build.gradle\nplugins {\n    id(\"androidx.navigation.safeargs\")\n}\n\n// Generated class for arguments\nclass ProfileFragmentArgs private constructor() : NavArgs {\n    val userId: Int\n}\n\n// Usage\nval args = ProfileFragmentArgs.fromBundle(requireArguments())",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_theory_6",
              "questionText": "What is the difference between popUpTo and popUpToInclusive?",
              "type": "THEORY",
              "correctAnswer": "popUpTo navigates back to a specified destination in the back stack. popUpToInclusive does the same but also removes that destination from the back stack.",
              "explanation": "These attributes are used in navigation actions to control the back stack behavior when navigating to a new destination.",
              "codeExample": "<action\n    android:id=\"@+id/action_home_to_profile\"\n    app:destination=\"@id/profileFragment\"\n    app:popUpTo=\"@id/homeFragment\"\n    app:popUpToInclusive=\"true\" />",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "navigation_theory_7",
              "questionText": "How do you handle the Up button with Navigation Component?",
              "type": "THEORY",
              "correctAnswer": "You configure the Up button in the Activity by setting up the AppBar with NavigationUI, which automatically handles navigation based on the current destination.",
              "explanation": "NavigationUI provides methods to connect your app bar with the Navigation Component, handling the Up button and back button behavior automatically.",
              "codeExample": "val navController = findNavController(R.id.nav_host_fragment)\nval appBarConfiguration = AppBarConfiguration(navController.graph)\n\nsetupActionBarWithNavController(navController, appBarConfiguration)",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_theory_8",
              "questionText": "What are nested navigation graphs?",
              "type": "THEORY",
              "correctAnswer": "Nested navigation graphs allow you to organize navigation into logical groups by including one navigation graph within another, improving modularity and reusability.",
              "explanation": "Nested graphs help organize complex navigation flows and can be reused across different parts of your app.",
              "codeExample": "<navigation\n    android:id=\"@+id/main_graph\"\n    app:startDestination=\"@id/homeFragment\">\n    \n    <include app:graph=\"@navigation/settings_graph\" />\n</navigation>",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "navigation_quiz_1",
              "questionText": "What is the purpose of NavHost?",
              "type": "MCQ",
              "options": ["To host activities", "To display navigation destinations", "To store navigation data", "To handle network requests"],
              "correctAnswer": "To display navigation destinations",
              "explanation": "NavHost is a container that displays destinations from your navigation graph.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_2",
              "questionText": "Which class manages navigation within a NavHost?",
              "type": "MCQ",
              "options": ["NavHost", "NavController", "NavigationGraph", "NavDestination"],
              "correctAnswer": "NavController",
              "explanation": "NavController manages app navigation within a NavHost.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_3",
              "questionText": "What method is used to navigate to a destination?",
              "type": "MCQ",
              "options": ["goTo()", "navigate()", "moveTo()", "travelTo()"],
              "correctAnswer": "navigate()",
              "explanation": "navigate() is the method used to navigate between destinations.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_4",
              "questionText": "What is Safe Args used for?",
              "type": "MCQ",
              "options": ["To safely navigate", "To pass type-safe arguments", "To secure the app", "To validate navigation"],
              "correctAnswer": "To pass type-safe arguments",
              "explanation": "Safe Args provides type-safe argument passing between destinations.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_5",
              "questionText": "How do you get the NavController in a Fragment?",
              "type": "MCQ",
              "options": ["NavController.getInstance()", "findNavController()", "getNavController()", "NavController.get()"],
              "correctAnswer": "findNavController()",
              "explanation": "findNavController() is the extension function to get the NavController in a Fragment.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_6",
              "questionText": "What does popUpTo do?",
              "type": "MCQ",
              "options": ["Pops up a dialog", "Navigates back to a destination", "Removes all destinations", "Adds a destination"],
              "correctAnswer": "Navigates back to a destination",
              "explanation": "popUpTo navigates back to a specified destination in the back stack.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_quiz_7",
              "questionText": "What is the purpose of NavigationUI?",
              "type": "MCQ",
              "options": ["To design UI", "To connect UI components with NavController", "To create navigation graphs", "To handle animations"],
              "correctAnswer": "To connect UI components with NavController",
              "explanation": "NavigationUI helps connect UI components like toolbars and bottom navigation with NavController.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_quiz_8",
              "questionText": "Can Navigation Component be used with multiple activities?",
              "type": "MCQ",
              "options": ["No, only single activity", "Yes, with multiple NavHosts", "Yes, automatically", "No, only fragments"],
              "correctAnswer": "Yes, with multiple NavHosts",
              "explanation": "Navigation Component can work with multiple activities, each having its own NavHost.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "navigation_quiz_9",
              "questionText": "What is a deep link in Navigation Component?",
              "type": "MCQ",
              "options": ["A link to a website", "A URL that navigates to a specific destination", "A network connection", "A database link"],
              "correctAnswer": "A URL that navigates to a specific destination",
              "explanation": "Deep links allow users to navigate directly to a specific destination using a URL.",
              "difficulty": "EASY"
            },
            {
              "id": "navigation_quiz_10",
              "questionText": "What is the startDestination in a navigation graph?",
              "type": "MCQ",
              "options": ["The first destination shown", "The last destination", "The main activity", "The home screen"],
              "correctAnswer": "The first destination shown",
              "explanation": "startDestination is the first destination displayed when the navigation graph is loaded.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_dependency_injection",
          "name": "Dependency Injection",
          "description": "DI with Dagger Hilt and Koin",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "di_theory_1",
              "questionText": "What is Dependency Injection?",
              "type": "THEORY",
              "correctAnswer": "Dependency Injection is a design pattern where dependencies are provided to a class rather than the class creating them itself, promoting loose coupling and testability.",
              "explanation": "DI makes code more modular, testable, and maintainable by removing hard-coded dependencies and allowing them to be swapped easily.",
              "codeExample": "// Without DI\nclass UserRepository {\n    private val apiService = ApiService() // Hard dependency\n}\n\n// With DI\nclass UserRepository(private val apiService: ApiService) {\n    // Dependency injected\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "di_theory_2",
              "questionText": "What is Dagger Hilt?",
              "type": "THEORY",
              "correctAnswer": "Dagger Hilt is Android's recommended dependency injection library built on top of Dagger, providing a simpler way to implement DI in Android apps.",
              "explanation": "Hilt reduces the boilerplate code of Dagger and provides Android-specific integrations for ViewModels, Activities, and Fragments.",
              "codeExample": "@HiltAndroidApp\nclass MyApplication : Application()\n\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject lateinit var userRepository: UserRepository\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "di_theory_3",
              "questionText": "What is the @Inject annotation in Hilt?",
              "type": "THEORY",
              "correctAnswer": "@Inject tells Hilt how to provide instances of a class. It can be used on constructors (to tell Hilt how to create the class) or on fields (to request injection).",
              "explanation": "When used on a constructor, @Inject marks the class as one that Hilt can provide. When used on a field, it requests Hilt to provide that dependency.",
              "codeExample": "// Constructor injection\nclass UserRepository @Inject constructor(\n    private val apiService: ApiService\n)\n\n// Field injection\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    @Inject lateinit var userRepository: UserRepository\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "di_theory_4",
              "questionText": "What is a Module in Hilt?",
              "type": "THEORY",
              "correctAnswer": "A Module is a class annotated with @Module that tells Hilt how to provide dependencies from third-party libraries or interfaces that you can't annotate with @Inject.",
              "explanation": "Modules contain methods annotated with @Provides or @Binds that tell Hilt how to create instances of specific types.",
              "codeExample": "@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    \n    @Provides\n    @Singleton\n    fun provideRetrofit(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(BASE_URL)\n            .build()\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "di_theory_5",
              "questionText": "What is the difference between @Provides and @Binds?",
              "type": "THEORY",
              "correctAnswer": "@Provides is used for methods that create instances, typically for third-party classes or complex creation logic. @Binds is used for abstract methods that bind interfaces to implementations.",
              "explanation": "@Provides methods can contain logic to create instances. @Binds methods are abstract and simply declare which implementation to use for an interface.",
              "codeExample": "// @Provides - for creating instances\n@Provides\nfun provideApiService(): ApiService {\n    return Retrofit.Builder().build().create(ApiService::class.java)\n}\n\n// @Binds - for interface to implementation binding\n@Binds\nabstract fun bindUserRepository(\n    impl: UserRepositoryImpl\n): UserRepository",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "di_theory_6",
              "questionText": "What are the different component scopes in Hilt?",
              "type": "THEORY",
              "correctAnswer": "Hilt provides several component scopes: SingletonComponent (app-level), ActivityComponent, FragmentComponent, ViewModelComponent, and ServiceComponent, each with different lifecycles.",
              "explanation": "Components define the scope of dependencies. SingletonComponent lives for the app's lifetime, while others are tied to specific Android components.",
              "codeExample": "@Singleton // Lives as long as the app\nclass UserRepository @Inject constructor()\n\n@ActivityScoped // Lives as long as the activity\nclass ActivityRepository @Inject constructor()\n\n@FragmentScoped // Lives as long as the fragment\nclass FragmentRepository @Inject constructor()",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "di_theory_7",
              "questionText": "How do you inject dependencies into a ViewModel with Hilt?",
              "type": "THEORY",
              "correctAnswer": "You annotate the ViewModel with @HiltViewModel and use @Inject on its constructor. Hilt will automatically provide the dependencies and create the ViewModel.",
              "explanation": "Hilt provides special support for ViewModels through the @HiltViewModel annotation, making it easy to inject dependencies.",
              "codeExample": "@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val userRepository: UserRepository,\n    private val postRepository: PostRepository\n) : ViewModel() {\n    // ...\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "di_theory_8",
              "questionText": "What is Koin and how does it differ from Hilt?",
              "type": "THEORY",
              "correctAnswer": "Koin is a lightweight Kotlin dependency injection framework that uses a DSL instead of annotation processing. It's simpler to set up but has less compile-time safety than Hilt.",
              "explanation": "Koin doesn't use code generation or annotation processing, making it faster to build but with less compile-time error checking compared to Hilt/Dagger.",
              "codeExample": "// Koin module\nval appModule = module {\n    single { ApiService() }\n    factory { UserRepository(get()) }\n}\n\n// Start Koin\nstartKoin {\n    androidContext(this)\n    modules(appModule)\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "di_quiz_1",
              "questionText": "What is the main benefit of Dependency Injection?",
              "type": "MCQ",
              "options": ["Faster app performance", "Better code organization and testability", "Smaller APK size", "Better UI design"],
              "correctAnswer": "Better code organization and testability",
              "explanation": "DI promotes loose coupling, making code more modular, testable, and maintainable.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_2",
              "questionText": "Which annotation marks the Application class for Hilt?",
              "type": "MCQ",
              "options": ["@HiltApp", "@HiltAndroidApp", "@DaggerApp", "@InjectApp"],
              "correctAnswer": "@HiltAndroidApp",
              "explanation": "@HiltAndroidApp triggers Hilt's code generation and must be on the Application class.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_3",
              "questionText": "What annotation is used to inject dependencies into an Activity?",
              "type": "MCQ",
              "options": ["@InjectActivity", "@AndroidEntryPoint", "@HiltActivity", "@Inject"],
              "correctAnswer": "@AndroidEntryPoint",
              "explanation": "@AndroidEntryPoint enables dependency injection for Android components like Activities.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_4",
              "questionText": "What is a Module in Hilt used for?",
              "type": "MCQ",
              "options": ["To define app modules", "To provide dependencies from third-party libraries", "To create activities", "To define UI layouts"],
              "correctAnswer": "To provide dependencies from third-party libraries",
              "explanation": "Modules tell Hilt how to provide dependencies that can't be annotated with @Inject.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_5",
              "questionText": "Which annotation marks a method that provides a dependency?",
              "type": "MCQ",
              "options": ["@Provide", "@Provides", "@Inject", "@Binds"],
              "correctAnswer": "@Provides",
              "explanation": "@Provides marks a method that tells Hilt how to create an instance of a type.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_6",
              "questionText": "What is the purpose of @Singleton annotation?",
              "type": "MCQ",
              "options": ["To make a class single-threaded", "To ensure only one instance exists", "To make a class abstract", "To prevent inheritance"],
              "correctAnswer": "To ensure only one instance exists",
              "explanation": "@Singleton ensures that only one instance of the dependency is created and reused.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_7",
              "questionText": "How do you inject into a ViewModel with Hilt?",
              "type": "MCQ",
              "options": ["@InjectViewModel", "@HiltViewModel", "@ViewModelInject", "@AndroidViewModel"],
              "correctAnswer": "@HiltViewModel",
              "explanation": "@HiltViewModel marks a ViewModel for Hilt dependency injection.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_8",
              "questionText": "What is the difference between @Provides and @Binds?",
              "type": "MCQ",
              "options": ["No difference", "@Provides creates instances, @Binds binds interfaces", "@Binds creates instances, @Provides binds interfaces", "Both create instances"],
              "correctAnswer": "@Provides creates instances, @Binds binds interfaces",
              "explanation": "@Provides is for creating instances with logic. @Binds is for binding interfaces to implementations.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "di_quiz_9",
              "questionText": "What component scope is used for app-level singletons?",
              "type": "MCQ",
              "options": ["ActivityComponent", "FragmentComponent", "SingletonComponent", "ViewModelComponent"],
              "correctAnswer": "SingletonComponent",
              "explanation": "SingletonComponent is the app-level component that lives for the entire app lifetime.",
              "difficulty": "EASY"
            },
            {
              "id": "di_quiz_10",
              "questionText": "What is Koin?",
              "type": "MCQ",
              "options": ["A testing framework", "A lightweight DI framework for Kotlin", "A UI library", "A database library"],
              "correctAnswer": "A lightweight DI framework for Kotlin",
              "explanation": "Koin is a pragmatic lightweight dependency injection framework for Kotlin developers.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_testing",
          "name": "Testing",
          "description": "Unit, integration, and UI testing",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "testing_theory_1",
              "questionText": "What are the different types of testing in Android?",
              "type": "THEORY",
              "correctAnswer": "The main types are: Unit tests (test individual functions/classes in isolation), Integration tests (test interactions between components), and UI tests (test user interactions and app behavior).",
              "explanation": "Unit tests are fast and test logic in isolation. Integration tests verify component interactions. UI tests verify the app behaves correctly from the user's perspective.",
              "codeExample": "// Unit test (local test)\n@Test\nfun addition_isCorrect() {\n    assertEquals(4, 2 + 2)\n}\n\n// UI test (instrumented test)\n@Test\nfun loginButtonClick_performsLogin() {\n    composeTestRule\n        .onNodeWithText(\"Login\")\n        .performClick()\n        .assertIsDisplayed()\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "testing_theory_2",
              "questionText": "What is the difference between local tests and instrumented tests?",
              "type": "THEORY",
              "correctAnswer": "Local tests run on the JVM without Android dependencies and are fast. Instrumented tests run on an Android device or emulator and can access Android framework APIs.",
              "explanation": "Local tests are in src/test and run quickly. Instrumented tests are in src/androidTest and require an Android device/emulator to run.",
              "codeExample": "// Local test - src/test/java/\n@Test\nfun calculateSum() {\n    val result = Calculator.add(2, 3)\n    assertEquals(5, result)\n}\n\n// Instrumented test - src/androidTest/java/\n@Test\nfun buttonClick_updatesText() {\n    Espresso.onView(R.id.button).perform(click())\n    Espresso.onView(R.id.textView).check(matches(withText(\"Updated\")))\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "testing_theory_3",
              "questionText": "What is JUnit and how is it used in Android testing?",
              "type": "THEORY",
              "correctAnswer": "JUnit is a testing framework for Java and Kotlin that provides annotations and assertions for writing and running unit tests.",
              "explanation": "JUnit provides @Test, @Before, @After annotations and assertion methods like assertEquals, assertTrue for writing tests.",
              "codeExample": "import org.junit.Test\nimport org.junit.Assert.*\n\nclass CalculatorTest {\n    @Test\n    fun addition_isCorrect() {\n        val result = 2 + 2\n        assertEquals(4, result)\n    }\n    \n    @Before\n    fun setup() {\n        // Runs before each test\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "testing_theory_4",
              "questionText": "What is Mockito and when would you use it?",
              "type": "THEORY",
              "correctAnswer": "Mockito is a mocking framework that allows you to create mock objects for testing. It's used to isolate dependencies and test code in isolation.",
              "explanation": "Mockito lets you create mock implementations of interfaces and classes, verify method calls, and stub return values for testing.",
              "codeExample": "@Test\nfun testWithMock() {\n    val mockRepository = mock<UserRepository>()\n    `when`(mockRepository.getUser(1)).thenReturn(User(id = 1, name = \"John\"))\n    \n    val viewModel = MyViewModel(mockRepository)\n    viewModel.loadUser(1)\n    \n    verify(mockRepository).getUser(1)\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "testing_theory_5",
              "questionText": "What is Espresso and what is it used for?",
              "type": "THEORY",
              "correctAnswer": "Espresso is Google's UI testing framework that allows you to simulate user interactions and verify UI state in automated tests.",
              "explanation": "Espresso provides a fluent API to find views, perform actions, and verify assertions, making it easy to write UI tests.",
              "codeExample": "@Test\nfun clickButton_updatesText() {\n    // Find view and perform click\n    Espresso.onView(withId(R.id.button))\n        .perform(click())\n    \n    // Verify text changed\n    Espresso.onView(withId(R.id.textView))\n        .check(matches(withText(\"Clicked\")))\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "testing_theory_6",
              "questionText": "What is Robolectric?",
              "type": "THEORY",
              "correctAnswer": "Robolectric is a framework that allows you to run Android tests on the JVM without an emulator or device, by providing a simulated Android environment.",
              "explanation": "Robolectric lets you write tests that use Android framework APIs but run as fast as local JVM tests, improving test execution speed.",
              "codeExample": "@RunWith(RobolectricTestRunner::class)\nclass MyActivityTest {\n    @Test\n    fun clickingButton_updatesText() {\n        val activity = Robolectric.buildActivity(MainActivity::class.java)\n            .create()\n            .get()\n        \n        activity.findViewById<Button>(R.id.button).performClick()\n        \n        val textView = activity.findViewById<TextView>(R.id.textView)\n        assertEquals(\"Updated\", textView.text.toString())\n    }\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "testing_theory_7",
              "questionText": "What is the difference between @Before and @BeforeClass?",
              "type": "THEORY",
              "correctAnswer": "@Before runs before each test method. @BeforeClass runs once before all test methods in the class and must be static.",
              "explanation": "Use @Before for setup that needs to run before each test. Use @BeforeClass for expensive setup that can be shared across all tests.",
              "codeExample": "class MyTest {\n    companion object {\n        @BeforeClass\n        @JvmStatic\n        fun setupClass() {\n            // Runs once before all tests\n        }\n    }\n    \n    @Before\n    fun setup() {\n        // Runs before each test\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "testing_theory_8",
              "questionText": "What is Test-Driven Development (TDD)?",
              "type": "THEORY",
              "correctAnswer": "TDD is a development approach where you write tests before writing the production code, following a red-green-refactor cycle.",
              "explanation": "In TDD, you first write a failing test (red), then write the minimum code to make it pass (green), then refactor to improve code quality.",
              "codeExample": "// 1. Write failing test (red)\n@Test\nfun calculateSum() {\n    assertEquals(5, Calculator.add(2, 3))\n}\n\n// 2. Write code to make test pass (green)\nfun add(a: Int, b: Int): Int = a + b\n\n// 3. Refactor if needed",
              "imageUrl": "",
              "difficulty": "EASY"
            }
          ],
          "quizQuestions": [
            {
              "id": "testing_quiz_1",
              "questionText": "Where are local unit tests placed?",
              "type": "MCQ",
              "options": ["src/androidTest/java", "src/test/java", "src/main/java", "src/debug/java"],
              "correctAnswer": "src/test/java",
              "explanation": "Local unit tests are placed in src/test/java and run on the JVM.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_2",
              "questionText": "Where are instrumented tests placed?",
              "type": "MCQ",
              "options": ["src/androidTest/java", "src/test/java", "src/main/java", "src/release/java"],
              "correctAnswer": "src/androidTest/java",
              "explanation": "Instrumented tests are placed in src/androidTest/java and run on Android devices/emulators.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_3",
              "questionText": "Which annotation marks a test method?",
              "type": "MCQ",
              "options": ["@Test", "@TestCase", "@TestMethod", "@Run"],
              "correctAnswer": "@Test",
              "explanation": "@Test marks a method as a test method in JUnit.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_4",
              "questionText": "What is Mockito used for?",
              "type": "MCQ",
              "options": ["UI testing", "Creating mock objects", "Network testing", "Database testing"],
              "correctAnswer": "Creating mock objects",
              "explanation": "Mockito is used to create mock objects for testing in isolation.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_5",
              "questionText": "What is Espresso used for?",
              "type": "MCQ",
              "options": ["Unit testing", "UI testing", "Network testing", "Database testing"],
              "correctAnswer": "UI testing",
              "explanation": "Espresso is Google's UI testing framework for Android.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_6",
              "questionText": "What does Robolectric allow you to do?",
              "type": "MCQ",
              "options": ["Run tests on iOS", "Run Android tests on JVM", "Run tests on web", "Run tests without code"],
              "correctAnswer": "Run Android tests on JVM",
              "explanation": "Robolectric allows running Android tests on the JVM without an emulator.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "testing_quiz_7",
              "questionText": "When does @Before run?",
              "type": "MCQ",
              "options": ["Once before all tests", "Before each test", "After each test", "Once after all tests"],
              "correctAnswer": "Before each test",
              "explanation": "@Before runs before each test method in the class.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_8",
              "questionText": "What is the red-green-refactor cycle in TDD?",
              "type": "MCQ",
              "options": ["Write code, test, refactor", "Write failing test, make it pass, refactor", "Refactor, test, write code", "Test, refactor, write code"],
              "correctAnswer": "Write failing test, make it pass, refactor",
              "explanation": "TDD follows red (failing test), green (passing test), refactor cycle.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_9",
              "questionText": "What assertion checks if two values are equal?",
              "type": "MCQ",
              "options": ["assertTrue()", "assertFalse()", "assertEquals()", "assertNull()"],
              "correctAnswer": "assertEquals()",
              "explanation": "assertEquals() checks if two values are equal.",
              "difficulty": "EASY"
            },
            {
              "id": "testing_quiz_10",
              "questionText": "What is the purpose of mocking in tests?",
              "type": "MCQ",
              "options": ["To make tests faster", "To isolate dependencies", "To make tests harder", "To increase code size"],
              "correctAnswer": "To isolate dependencies",
              "explanation": "Mocking allows you to isolate dependencies and test code in isolation.",
              "difficulty": "EASY"
            }
          ]
        },
        {
          "id": "android_performance",
          "name": "Performance Optimization",
          "description": "App performance and memory optimization",
          "iconUrl": "https://img.icons8.com/color/96/android-os.png",
          "questions": [
            {
              "id": "performance_theory_1",
              "questionText": "What are some common performance issues in Android apps?",
              "type": "THEORY",
              "correctAnswer": "Common issues include: memory leaks, slow UI rendering, blocking the main thread, inefficient layouts, excessive network calls, and large image sizes.",
              "explanation": "Performance issues can manifest as slow app startup, janky animations, ANRs, and poor battery life. Identifying and fixing these is crucial for user experience.",
              "codeExample": "// Common performance issues:\n// 1. Memory leaks - holding references to destroyed activities\n// 2. Main thread blocking - network/database on main thread\n// 3. Inefficient layouts - deep view hierarchies\n// 4. Large images - not compressing or caching",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "performance_theory_2",
              "questionText": "What is a memory leak in Android?",
              "type": "THEORY",
              "correctAnswer": "A memory leak occurs when an object that is no longer needed is still being referenced, preventing the garbage collector from reclaiming its memory.",
              "explanation": "Common causes include static references, non-static inner classes holding outer class references, and not unregistering listeners.",
              "codeExample": "// Memory leak example\nclass MyActivity : AppCompatActivity() {\n    companion object {\n        // Static reference holds activity - causes leak!\n        var leakedActivity: MyActivity? = null\n    }\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        leakedActivity = this // Leak!\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "performance_theory_3",
              "questionText": "What tools can you use to detect memory leaks?",
              "type": "THEORY",
              "correctAnswer": "Tools for detecting memory leaks include: Android Profiler (Memory profiler), LeakCanary library, and heap dump analysis.",
              "explanation": "Android Profiler shows real-time memory usage. LeakCanary automatically detects and reports memory leaks in debug builds.",
              "codeExample": "// Add LeakCanary to dependencies\ndependencies {\n    debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.12\")\n}\n\n// LeakCanary automatically detects leaks\n// and shows notifications in debug builds",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "performance_theory_4",
              "questionText": "What is ANR (Application Not Responding)?",
              "type": "THEORY",
              "correctAnswer": "ANR occurs when the main thread is blocked for too long (typically 5+ seconds), preventing the app from responding to user input.",
              "explanation": "ANRs happen when you perform long operations on the main thread like network calls, database operations, or complex calculations.",
              "codeExample": "// Causes ANR - blocking main thread\nfun badExample() {\n    Thread.sleep(10000) // Blocks for 10 seconds!\n}\n\n// Good example - use coroutines\nfun goodExample() {\n    viewModelScope.launch {\n        delay(10000) // Non-blocking\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "performance_theory_5",
              "questionText": "How do you optimize RecyclerView performance?",
              "type": "THEORY",
              "correctAnswer": "RecyclerView optimization techniques include: using ViewHolder pattern, implementing DiffUtil, avoiding nested layouts, using efficient image loading, and setting setHasFixedSize(true).",
              "explanation": "ViewHolder pattern avoids repeated findViewById calls. DiffUtil efficiently updates only changed items. Avoiding nested layouts reduces measure time.",
              "codeExample": "// Use ViewHolder pattern\nclass MyViewHolder(view: View) : RecyclerView.ViewHolder(view) {\n    val textView: TextView = view.findViewById(R.id.text)\n}\n\n// Use DiffUtil for efficient updates\nclass MyDiffUtil : DiffUtil.ItemCallback<Item>() {\n    override fun areItemsTheSame(old: Item, new: Item): Boolean =\n        old.id == new.id\n    \n    override fun areContentsTheSame(old: Item, new: Item): Boolean =\n        old == new\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "performance_theory_6",
              "questionText": "What is the difference between synchronous and asynchronous operations?",
              "type": "THEORY",
              "correctAnswer": "Synchronous operations block the calling thread until complete. Asynchronous operations allow the calling thread to continue while the operation completes in the background.",
              "explanation": "Synchronous operations on the main thread cause UI freezes. Asynchronous operations using coroutines or callbacks keep the UI responsive.",
              "codeExample": "// Synchronous - blocks thread\nval data = fetchData() // Blocks until complete\n\n// Asynchronous - doesn't block\nviewModelScope.launch {\n    val data = fetchData() // Runs in background\n    withContext(Dispatchers.Main) {\n        updateUI(data)\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "performance_theory_7",
              "questionText": "What is the purpose of the Android Profiler?",
              "type": "THEORY",
              "correctAnswer": "Android Profiler is a tool that provides real-time data about your app's CPU, memory, network, and energy usage, helping you identify performance issues.",
              "explanation": "Profiler helps you track down performance bottlenecks, memory leaks, excessive network usage, and battery drain issues.",
              "codeExample": "// Android Profiler provides:\n// 1. CPU Profiler - track CPU usage and thread activity\n// 2. Memory Profiler - track memory allocation and detect leaks\n// 3. Network Profiler - monitor network traffic\n// 4. Energy Profiler - track battery usage",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "performance_theory_8",
              "questionText": "How do you optimize image loading in Android?",
              "type": "THEORY",
              "correctAnswer": "Image optimization techniques include: using image loading libraries like Glide or Coil, compressing images, using appropriate image formats, implementing caching, and loading images at the right size.",
              "explanation": "Efficient image loading prevents memory issues and improves scrolling performance. Libraries handle caching, resizing, and memory management automatically.",
              "codeExample": "// Using Glide for optimized image loading\nGlide.with(context)\n    .load(imageUrl)\n    .placeholder(R.drawable.placeholder)\n    .error(R.drawable.error)\n    .override(200, 200) // Load at appropriate size\n    .diskCacheStrategy(DiskCacheStrategy.ALL)\n    .into(imageView)",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "performance_quiz_1",
              "questionText": "What causes ANR?",
              "type": "MCQ",
              "options": ["Memory leak", "Blocking the main thread", "Network error", "Database error"],
              "correctAnswer": "Blocking the main thread",
              "explanation": "ANR occurs when the main thread is blocked for too long.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_2",
              "questionText": "What is a memory leak?",
              "type": "MCQ",
              "options": ["Running out of memory", "Objects not being garbage collected", "Slow app startup", "Network timeout"],
              "correctAnswer": "Objects not being garbage collected",
              "explanation": "Memory leaks occur when objects are still referenced but no longer needed.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_3",
              "questionText": "Which tool helps detect memory leaks?",
              "type": "MCQ",
              "options": ["Logcat", "LeakCanary", "ADB", "Gradle"],
              "correctAnswer": "LeakCanary",
              "explanation": "LeakCanary is a library that automatically detects memory leaks.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_4",
              "questionText": "What is the purpose of ViewHolder in RecyclerView?",
              "type": "MCQ",
              "options": ["To hold data", "To cache view references", "To create views", "To delete views"],
              "correctAnswer": "To cache view references",
              "explanation": "ViewHolder caches view references to avoid repeated findViewById calls.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_5",
              "questionText": "What does DiffUtil do?",
              "type": "MCQ",
              "options": ["Creates differences", "Efficiently updates RecyclerView with minimal changes", "Deletes items", "Adds items"],
              "correctAnswer": "Efficiently updates RecyclerView with minimal changes",
              "explanation": "DiffUtil calculates the difference between old and new lists and updates only changed items.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "performance_quiz_6",
              "questionText": "Which library is commonly used for image loading?",
              "type": "MCQ",
              "options": ["Retrofit", "Glide", "Room", "Navigation"],
              "correctAnswer": "Glide",
              "explanation": "Glide is a popular image loading library for Android.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_7",
              "questionText": "What does Android Profiler monitor?",
              "type": "MCQ",
              "options": ["Only CPU", "Only memory", "CPU, memory, network, and energy", "Only network"],
              "correctAnswer": "CPU, memory, network, and energy",
              "explanation": "Android Profiler monitors CPU, memory, network, and energy usage.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_8",
              "questionText": "How long can the main thread be blocked before ANR?",
              "type": "MCQ",
              "options": ["1 second", "5 seconds", "10 seconds", "30 seconds"],
              "correctAnswer": "5 seconds",
              "explanation": "ANR typically occurs when the main thread is blocked for 5+ seconds.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_9",
              "questionText": "What is the benefit of using coroutines for network calls?",
              "type": "MCQ",
              "options": ["Faster execution", "Non-blocking operations", "Smaller code", "Better security"],
              "correctAnswer": "Non-blocking operations",
              "explanation": "Coroutines allow non-blocking operations, keeping the UI responsive.",
              "difficulty": "EASY"
            },
            {
              "id": "performance_quiz_10",
              "questionText": "What does setHasFixedSize(true) do in RecyclerView?",
              "type": "MCQ",
              "options": ["Sets item size", "Optimizes layout when item sizes don't change", "Makes items fixed size", "Disables scrolling"],
              "correctAnswer": "Optimizes layout when item sizes don't change",
              "explanation": "setHasFixedSize(true) optimizes RecyclerView when all items have the same dimensions.",
              "difficulty": "MEDIUM"
            }
          ]
        }
      ]
    },
    {
      "id": "kotlin",
      "name": "Kotlin",
      "description": "Modern programming language for Android",
      "iconUrl": "https://img.icons8.com/color/96/kotlin.png",
      "topics": [
        {
          "id": "kotlin_basics",
          "name": "Kotlin Fundamentals",
          "description": "Core Kotlin language features",
          "iconUrl": "https://img.icons8.com/color/96/kotlin.png",
          "questions": [
            {
              "id": "kotlin_theory_1",
              "questionText": "What is the difference between 'val' and 'var' in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "'val' declares a read-only (immutable) variable that can be assigned only once, while 'var' declares a mutable variable that can be reassigned multiple times.",
              "explanation": "Using 'val' promotes immutability and functional programming principles, making code safer and easier to reason about.",
              "codeExample": "val immutable = \"Cannot be changed\"\nvar mutable = \"Can be changed\"\nmutable = \"New value\"",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_theory_2",
              "questionText": "What is null safety in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "Kotlin's type system distinguishes between nullable and non-nullable types, preventing null pointer exceptions at compile time.",
              "explanation": "By default, variables cannot be null. If you need a nullable variable, you use the '?' operator.",
              "codeExample": "var nonNull: String = \"Hello\"\nvar nullable: String? = \"World\"\nnullable = null\nval length = nullable?.length ?: 0",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_theory_3",
              "questionText": "What is a data class in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "A data class is a class designed to hold data. The compiler automatically generates equals(), hashCode(), toString(), copy(), and componentN() methods.",
              "explanation": "Data classes reduce boilerplate code significantly and are perfect for modeling data structures.",
              "codeExample": "data class User(val name: String, val age: Int)\n\nval user = User(\"John\", 30)\nval olderUser = user.copy(age = 31)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_theory_4",
              "questionText": "What are extension functions in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "Extension functions allow you to add new functions to existing classes without inheriting from them or using design patterns like Decorator.",
              "explanation": "Extension functions are resolved statically, meaning they don't modify the actual class but provide a way to call new functions as if they were part of the class.",
              "codeExample": "fun String.addExclamation(): String {\n    return this + \"!\"\n}\n\nval greeting = \"Hello\".addExclamation() // \"Hello!\"",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_theory_5",
              "questionText": "What is the 'when' expression in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "The 'when' expression is Kotlin's replacement for the switch statement in Java. It's more powerful and can be used as an expression or statement.",
              "explanation": "when can check values, types, ranges, and more. It can also return a value when used as an expression.",
              "codeExample": "val result = when (value) {\n    1 -> \"One\"\n    2 -> \"Two\"\n    else -> \"Other\"\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_theory_6",
              "questionText": "What are higher-order functions in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "Higher-order functions are functions that take functions as parameters or return functions. They enable functional programming patterns.",
              "explanation": "Kotlin supports higher-order functions and lambdas, making it easy to work with functional programming concepts like map, filter, and reduce.",
              "codeExample": "fun calculate(x: Int, y: Int, operation: (Int, Int) -> Int): Int {\n    return operation(x, y)\n}\n\nval sum = calculate(5, 3) { a, b -> a + b }",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_theory_7",
              "questionText": "What is the 'apply' scope function in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "apply is a scope function that runs a block of code on an object and returns the object itself. It's useful for object configuration.",
              "explanation": "apply is commonly used for initializing objects where you need to set multiple properties.",
              "codeExample": "val person = Person().apply {\n    name = \"John\"\n    age = 30\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_theory_8",
              "questionText": "What is a sealed class in Kotlin?",
              "type": "THEORY",
              "correctAnswer": "A sealed class is a restricted class hierarchy that can have a finite number of subclasses. All subclasses must be declared in the same file.",
              "explanation": "Sealed classes are perfect for representing restricted class hierarchies when used in when expressions, as the compiler can check that all cases are covered.",
              "codeExample": "sealed class Result\ndata class Success(val data: String) : Result()\ndata class Error(val message: String) : Result()\nobject Loading : Result()",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "kotlin_quiz_1",
              "questionText": "What is a data class in Kotlin?",
              "type": "MCQ",
              "options": ["A class that can only hold primitive types", "A class automatically generates equals(), hashCode(), toString(), and copy() methods", "A class that handles database operations", "A class for networking"],
              "correctAnswer": "A class automatically generates equals(), hashCode(), toString(), and copy() methods",
              "explanation": "Data classes are designed to hold data and automatically generate useful methods.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_2",
              "questionText": "What operator is used for safe calls in Kotlin?",
              "type": "MCQ",
              "options": ["!!", "?", "?.", "?:"],
              "correctAnswer": "?.",
              "explanation": "The safe call operator ?. allows you to call methods or access properties on a nullable object without risking a NullPointerException.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_3",
              "questionText": "What is the Elvis operator in Kotlin?",
              "type": "MCQ",
              "options": ["!!", "?", "?.", "?:"],
              "correctAnswer": "?:",
              "explanation": "The Elvis operator ?: returns the left-hand side if it's not null, otherwise returns the right-hand side.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_4",
              "questionText": "What keyword is used to declare a function in Kotlin?",
              "type": "MCQ",
              "options": ["func", "function", "def", "fun"],
              "correctAnswer": "fun",
              "explanation": "The 'fun' keyword is used to declare functions in Kotlin.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_5",
              "questionText": "What is the difference between '==' and '===' in Kotlin?",
              "type": "MCQ",
              "options": ["No difference", "== compares values, === compares references", "== compares references, === compares values", "Both compare references"],
              "correctAnswer": "== compares values, === compares references",
              "explanation": "== checks structural equality (values), while === checks referential equality (same object in memory).",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_6",
              "questionText": "What is a lambda expression in Kotlin?",
              "type": "MCQ",
              "options": ["A type of class", "An anonymous function that can be treated as a value", "A variable declaration", "A loop construct"],
              "correctAnswer": "An anonymous function that can be treated as a value",
              "explanation": "Lambdas are anonymous functions that can be passed as arguments or stored in variables.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_7",
              "questionText": "What is the 'let' scope function used for?",
              "type": "MCQ",
              "options": ["To iterate over a list", "To execute code on a non-null object and return the result", "To modify an object", "To create a new object"],
              "correctAnswer": "To execute code on a non-null object and return the result",
              "explanation": "let is often used with safe call operator to execute code only if the object is not null.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_8",
              "questionText": "What does the 'it' keyword represent in Kotlin lambdas?",
              "type": "MCQ",
              "options": ["The current object", "The single parameter when it's implicit", "The return value", "The class name"],
              "correctAnswer": "The single parameter when it's implicit",
              "explanation": "When a lambda has a single parameter, you can omit the parameter name and use 'it' instead.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_9",
              "questionText": "What is the 'with' scope function used for?",
              "type": "MCQ",
              "options": ["To create a new object", "To execute code on an object without returning the object", "To check for null", "To iterate over a collection"],
              "correctAnswer": "To execute code on an object without returning the object",
              "explanation": "with is used to call multiple methods on an object without repeating the object reference.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_10",
              "questionText": "What is a companion object in Kotlin?",
              "type": "MCQ",
              "options": ["A singleton object", "A way to define static members in a class", "A type of inner class", "A data class"],
              "correctAnswer": "A way to define static members in a class",
              "explanation": "Companion objects are similar to static members in Java and are tied to the class rather than instances.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_11",
              "questionText": "What is the 'run' scope function used for?",
              "type": "MCQ",
              "options": ["To start a new thread", "To execute code on an object and return the result", "To run an app", "To create a loop"],
              "correctAnswer": "To execute code on an object and return the result",
              "explanation": "run is similar to let but can be used on both nullable and non-nullable objects.",
              "difficulty": "HARD"
            },
            {
              "id": "kotlin_quiz_12",
              "questionText": "What is the difference between List and MutableList in Kotlin?",
              "type": "MCQ",
              "options": ["No difference", "List is immutable, MutableList is mutable", "List is mutable, MutableList is immutable", "List is for primitives, MutableList is for objects"],
              "correctAnswer": "List is immutable, MutableList is mutable",
              "explanation": "List provides read-only operations, while MutableList allows modification of elements.",
              "difficulty": "EASY"
            },
            {
              "id": "kotlin_quiz_13",
              "questionText": "What is the 'also' scope function used for?",
              "type": "MCQ",
              "options": ["To perform additional actions and return the object", "To create a new object", "To filter a list", "To transform data"],
              "correctAnswer": "To perform additional actions and return the object",
              "explanation": "also is useful for performing additional operations like logging while returning the original object.",
              "difficulty": "HARD"
            },
            {
              "id": "kotlin_quiz_14",
              "questionText": "What is the '!!' operator used for in Kotlin?",
              "type": "MCQ",
              "options": ["To check for null", "To assert that a value is non-null and throw NPE if it is", "To create a new object", "To compare values"],
              "correctAnswer": "To assert that a value is non-null and throw NPE if it is",
              "explanation": "The non-null assertion operator !! converts a nullable type to a non-null type, throwing an exception if the value is null.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "kotlin_quiz_15",
              "questionText": "What is the 'map' function used for in Kotlin collections?",
              "type": "MCQ",
              "options": ["To filter elements", "To transform each element and return a new list", "To check if an element exists", "To sort elements"],
              "correctAnswer": "To transform each element and return a new list",
              "explanation": "map applies a transformation function to each element in a collection and returns a new list with the transformed elements.",
              "difficulty": "EASY"
            }
          ]
        }
      ]
    },
    {
      "id": "java",
      "name": "Java",
      "description": "Core Java programming concepts",
      "iconUrl": "https://img.icons8.com/color/96/java-coffee-cup-logo.png",
      "topics": [
        {
          "id": "java_basics",
          "name": "Java Fundamentals",
          "description": "Essential Java concepts",
          "iconUrl": "https://img.icons8.com/color/96/java-coffee-cup-logo.png",
          "questions": [
            {
              "id": "java_theory_1",
              "questionText": "What is the difference between JDK, JRE, and JVM?",
              "type": "THEORY",
              "correctAnswer": "JDK (Java Development Kit) is for developing Java applications. JRE (Java Runtime Environment) provides the runtime environment. JVM (Java Virtual Machine) executes Java bytecode.",
              "explanation": "JDK includes JRE plus development tools. JRE includes JVM plus standard libraries. JVM executes bytecode.",
              "codeExample": "// JDK contains: javac, java, JRE\n// JRE contains: JVM, standard libraries\n// JVM executes: .class files",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_theory_2",
              "questionText": "What is the difference between == and equals() in Java?",
              "type": "THEORY",
              "correctAnswer": "== compares references (memory addresses), while equals() compares the actual content/values of objects.",
              "explanation": "For primitive types, == compares values. For objects, == checks if they reference the same object. equals() should be overridden to compare object content.",
              "codeExample": "String s1 = new String(\"Hello\");\nString s2 = new String(\"Hello\");\n\ns1 == s2; // false (different references)\ns1.equals(s2); // true (same content)",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "java_theory_3",
              "questionText": "What is the difference between ArrayList and LinkedList in Java?",
              "type": "THEORY",
              "correctAnswer": "ArrayList uses a dynamic array internally, providing O(1) access but O(n) insertion/deletion. LinkedList uses a doubly-linked list, providing O(n) access but O(1) insertion/deletion at ends.",
              "explanation": "Use ArrayList for frequent access operations. Use LinkedList for frequent insertions/deletions, especially at the beginning or end.",
              "codeExample": "List<String> arrayList = new ArrayList<>(); // Fast access\nList<String> linkedList = new LinkedList<>(); // Fast insert/delete",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_theory_4",
              "questionText": "What is the difference between HashMap and Hashtable in Java?",
              "type": "THEORY",
              "correctAnswer": "HashMap is not synchronized and allows null keys/values. Hashtable is synchronized and doesn't allow null keys/values. HashMap is generally preferred.",
              "explanation": "HashMap is newer and more efficient. Use ConcurrentHashMap for thread-safe operations instead of Hashtable.",
              "codeExample": "Map<String, Integer> hashMap = new HashMap<>(); // Not synchronized\nMap<String, Integer> hashtable = new Hashtable<>(); // Synchronized",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_theory_5",
              "questionText": "What is the difference between interface and abstract class in Java?",
              "type": "THEORY",
              "correctAnswer": "An interface can only declare abstract methods (before Java 8) and constants. An abstract class can have both abstract and concrete methods, and can maintain state.",
              "explanation": "Use interfaces for defining contracts. Use abstract classes when you want to share code among related classes.",
              "codeExample": "interface MyInterface {\n    void doSomething();\n}\n\nabstract class MyAbstractClass {\n    abstract void doSomething();\n    void doCommonThing() { /* code */ }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_theory_6",
              "questionText": "What is the difference between throw and throws in Java?",
              "type": "THEORY",
              "correctAnswer": "throw is used to explicitly throw an exception. throws is used in method signature to declare that the method may throw exceptions.",
              "explanation": "throw is followed by an exception instance. throws is followed by exception class names and is part of method declaration.",
              "codeExample": "void method() throws IOException {\n    if (error) {\n        throw new IOException(\"Error occurred\");\n    }\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "java_theory_7",
              "questionText": "What is the difference between checked and unchecked exceptions in Java?",
              "type": "THEORY",
              "correctAnswer": "Checked exceptions must be declared in throws clause or caught with try-catch. Unchecked exceptions (RuntimeException and its subclasses) don't require this.",
              "explanation": "Checked exceptions represent recoverable conditions. Unchecked exceptions represent programming errors.",
              "codeExample": "// Checked exception\nvoid readFile() throws IOException { }\n\n// Unchecked exception\nvoid divide() {\n    int result = 10 / 0; // ArithmeticException\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_theory_8",
              "questionText": "What is the difference between String, StringBuilder, and StringBuffer?",
              "type": "THEORY",
              "correctAnswer": "String is immutable. StringBuilder is mutable and not thread-safe. StringBuffer is mutable and thread-safe (synchronized).",
              "explanation": "Use String for immutable text. Use StringBuilder for mutable text in single-threaded context. Use StringBuffer for mutable text in multi-threaded context.",
              "codeExample": "String s = \"Hello\"; // Immutable\nStringBuilder sb = new StringBuilder(\"Hello\"); // Mutable, not thread-safe\nStringBuffer sbf = new StringBuffer(\"Hello\"); // Mutable, thread-safe",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "java_quiz_1",
              "questionText": "Which keyword is used to inherit a class in Java?",
              "type": "MCQ",
              "options": ["implements", "extends", "inherits", "super"],
              "correctAnswer": "extends",
              "explanation": "The 'extends' keyword is used to inherit from a class in Java.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_2",
              "questionText": "Which keyword is used to implement an interface in Java?",
              "type": "MCQ",
              "options": ["extends", "implements", "inherits", "super"],
              "correctAnswer": "implements",
              "explanation": "The 'implements' keyword is used to implement an interface in Java.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_3",
              "questionText": "What is the default value of a boolean variable in Java?",
              "type": "MCQ",
              "options": ["true", "false", "null", "0"],
              "correctAnswer": "false",
              "explanation": "The default value of a boolean variable in Java is false.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_4",
              "questionText": "What is the purpose of the 'static' keyword in Java?",
              "type": "MCQ",
              "options": ["To make a variable constant", "To indicate that a member belongs to the class rather than instances", "To make a method private", "To prevent inheritance"],
              "correctAnswer": "To indicate that a member belongs to the class rather than instances",
              "explanation": "Static members belong to the class itself rather than to instances of the class.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_5",
              "questionText": "What is the 'final' keyword used for in Java?",
              "type": "MCQ",
              "options": ["To indicate the end of a block", "To make a variable, method, or class unchangeable", "To make a method abstract", "To indicate a method is overridden"],
              "correctAnswer": "To make a variable, method, or class unchangeable",
              "explanation": "final variables cannot be reassigned, final methods cannot be overridden, and final classes cannot be inherited.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_6",
              "questionText": "What is the difference between Stack and Heap memory?",
              "type": "MCQ",
              "options": ["No difference", "Stack stores objects, Heap stores primitives", "Stack stores method calls and primitives, Heap stores objects", "Heap stores method calls, Stack stores objects"],
              "correctAnswer": "Stack stores method calls and primitives, Heap stores objects",
              "explanation": "Stack memory is used for static memory allocation and method execution. Heap memory is used for dynamic memory allocation of objects.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_quiz_7",
              "questionText": "What is garbage collection in Java?",
              "type": "MCQ",
              "options": ["A way to manually delete objects", "Automatic memory management that reclaims memory used by unreachable objects", "A method to clean up resources", "A type of exception handling"],
              "correctAnswer": "Automatic memory management that reclaims memory used by unreachable objects",
              "explanation": "Garbage collection automatically identifies and removes objects that are no longer reachable, preventing memory leaks.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_8",
              "questionText": "What is the 'this' keyword used for in Java?",
              "type": "MCQ",
              "options": ["To refer to the parent class", "To refer to the current object instance", "To refer to a static member", "To create a new object"],
              "correctAnswer": "To refer to the current object instance",
              "explanation": "The 'this' keyword refers to the current object instance and is used to access instance variables and methods.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_9",
              "questionText": "What is method overloading in Java?",
              "type": "MCQ",
              "options": ["Having multiple methods with the same name but different parameters", "Redefining a method in a subclass", "Creating a method with no parameters", "Deleting a method"],
              "correctAnswer": "Having multiple methods with the same name but different parameters",
              "explanation": "Method overloading allows a class to have multiple methods with the same name but different parameter lists.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_10",
              "questionText": "What is method overriding in Java?",
              "type": "MCQ",
              "options": ["Having multiple methods with the same name", "Redefining a method in a subclass with the same signature", "Creating a static method", "Hiding a method"],
              "correctAnswer": "Redefining a method in a subclass with the same signature",
              "explanation": "Method overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_11",
              "questionText": "What is the 'super' keyword used for in Java?",
              "type": "MCQ",
              "options": ["To refer to the current object", "To refer to the parent class", "To create a new object", "To call a static method"],
              "correctAnswer": "To refer to the parent class",
              "explanation": "The 'super' keyword is used to refer to the immediate parent class object and to call parent class methods and constructors.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_12",
              "questionText": "What is the difference between HashSet and TreeSet?",
              "type": "MCQ",
              "options": ["No difference", "HashSet is unordered, TreeSet is sorted", "TreeSet is unordered, HashSet is sorted", "HashSet allows duplicates, TreeSet doesn't"],
              "correctAnswer": "HashSet is unordered, TreeSet is sorted",
              "explanation": "HashSet doesn't maintain any order. TreeSet maintains elements in sorted (natural) order.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "java_quiz_13",
              "questionText": "What is the purpose of the 'instanceof' operator?",
              "type": "MCQ",
              "options": ["To create a new instance", "To check if an object is an instance of a specific class or interface", "To compare objects", "To cast objects"],
              "correctAnswer": "To check if an object is an instance of a specific class or interface",
              "explanation": "The instanceof operator tests whether an object is an instance of a specified type.",
              "difficulty": "EASY"
            },
            {
              "id": "java_quiz_14",
              "questionText": "What is the difference between fail-fast and fail-safe iterators?",
              "type": "MCQ",
              "options": ["No difference", "Fail-fast throws ConcurrentModificationException, fail-safe doesn't", "Fail-safe throws exception, fail-fast doesn't", "Both throw exceptions"],
              "correctAnswer": "Fail-fast throws ConcurrentModificationException, fail-safe doesn't",
              "explanation": "Fail-fast iterators immediately throw ConcurrentModificationException if the collection is modified. Fail-safe iterators don't throw exceptions.",
              "difficulty": "HARD"
            },
            {
              "id": "java_quiz_15",
              "questionText": "What is the difference between PriorityQueue and LinkedList as a Queue?",
              "type": "MCQ",
              "options": ["No difference", "PriorityQueue orders by priority, LinkedList maintains insertion order", "LinkedList orders by priority, PriorityQueue maintains insertion order", "Both are the same"],
              "correctAnswer": "PriorityQueue orders by priority, LinkedList maintains insertion order",
              "explanation": "PriorityQueue orders elements based on their natural ordering or a comparator. LinkedList maintains FIFO order.",
              "difficulty": "MEDIUM"
            }
          ]
        }
      ]
    },
    {
      "id": "dsa",
      "name": "DSA",
      "description": "Data Structures and Algorithms",
      "iconUrl": "https://cdn-icons-png.flaticon.com/512/2997/2997302.png",
      "topics": [
        {
          "id": "dsa_arrays",
          "name": "Arrays & Strings",
          "description": "Array and string manipulation",
          "iconUrl": "https://img.icons8.com/color/96/data-structures.png",
          "questions": [
            {
              "id": "dsa_theory_1",
              "questionText": "What is a hash collision?",
              "type": "THEORY",
              "correctAnswer": "A hash collision occurs when two different keys produce the same hash value in a hash table. This is handled using techniques like chaining or open addressing.",
              "explanation": "Hash collisions are inevitable due to the pigeonhole principle. Good hash functions minimize collisions.",
              "codeExample": "class HashTable {\n    List<Entry>[] buckets;\n    void put(K key, V value) {\n        int hash = hash(key) % size;\n        buckets[hash].add(new Entry(key, value));\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_theory_2",
              "questionText": "What is the difference between array and linked list?",
              "type": "THEORY",
              "correctAnswer": "Arrays provide O(1) access but O(n) insertion/deletion. Linked lists provide O(n) access but O(1) insertion/deletion at known positions.",
              "explanation": "Arrays store elements contiguously in memory. Linked lists store elements in nodes with pointers to the next node.",
              "codeExample": "// Array: O(1) access, O(n) insert/delete\nint[] arr = new int[10];\n\n// Linked List: O(n) access, O(1) insert/delete\nLinkedList<Integer> list = new LinkedList<>();",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_theory_3",
              "questionText": "What is the two-pointer technique?",
              "type": "THEORY",
              "correctAnswer": "The two-pointer technique uses two pointers to traverse a data structure, often from opposite ends or at different speeds, to solve problems efficiently.",
              "explanation": "Commonly used for problems involving sorted arrays, finding pairs, or detecting cycles in linked lists.",
              "codeExample": "int left = 0, right = arr.length - 1;\nwhile (left < right) {\n    int sum = arr[left] + arr[right];\n    if (sum == target) return true;\n    else if (sum < target) left++;\n    else right--;\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_theory_4",
              "questionText": "What is the sliding window technique?",
              "type": "THEORY",
              "correctAnswer": "The sliding window technique maintains a window of elements that expands or contracts as it moves through the data structure, useful for subarray problems.",
              "explanation": "Used for problems involving finding subarrays with specific properties like sum, maximum, minimum, etc.",
              "codeExample": "int windowStart = 0, windowSum = 0;\nfor (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {\n    windowSum += arr[windowEnd];\n    while (windowSum >= target) {\n        windowSum -= arr[windowStart++];\n    }\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_theory_5",
              "questionText": "What is the difference between StringBuilder and String concatenation?",
              "type": "THEORY",
              "correctAnswer": "StringBuilder is mutable and efficient for multiple concatenations. String concatenation creates a new String object each time, which is inefficient.",
              "explanation": "String concatenation in loops creates many intermediate objects. StringBuilder modifies the same object in place.",
              "codeExample": "// Inefficient\nString result = \"\";\nfor (String s : strings) {\n    result += s; // Creates new object each time\n}\n\n// Efficient\nStringBuilder sb = new StringBuilder();\nfor (String s : strings) {\n    sb.append(s);\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_theory_6",
              "questionText": "What is the KMP algorithm used for?",
              "type": "THEORY",
              "correctAnswer": "The Knuth-Morris-Pratt (KMP) algorithm is used for pattern matching in strings. It finds all occurrences of a pattern in a text in O(n+m) time.",
              "explanation": "KMP preprocesses the pattern to create a partial match table (LPS array) that allows skipping unnecessary comparisons.",
              "codeExample": "int[] computeLPS(String pattern) {\n    int[] lps = new int[pattern.length()];\n    // Build LPS array\n    return lps;\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "dsa_theory_7",
              "questionText": "What is the difference between depth-first search (DFS) and breadth-first search (BFS)?",
              "type": "THEORY",
              "correctAnswer": "DFS explores as far as possible along each branch before backtracking. BFS explores all neighbors at the current depth before moving to the next level.",
              "explanation": "DFS uses a stack (or recursion). BFS uses a queue. DFS is good for finding paths, BFS is good for finding shortest paths.",
              "codeExample": "// DFS - uses stack or recursion\nvoid dfs(Node node) {\n    if (node == null) return;\n    visit(node);\n    for (Node child : node.children) {\n        dfs(child);\n    }\n}\n\n// BFS - uses queue\nvoid bfs(Node root) {\n    Queue<Node> queue = new LinkedList<>();\n    queue.add(root);\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_theory_8",
              "questionText": "What is dynamic programming?",
              "type": "THEORY",
              "correctAnswer": "Dynamic programming is an optimization technique that solves complex problems by breaking them down into simpler subproblems and storing the results to avoid redundant calculations.",
              "explanation": "Key principles: optimal substructure and overlapping subproblems. Can be implemented with memoization (top-down) or tabulation (bottom-up).",
              "codeExample": "// Fibonacci with memoization\nint[] memo = new int[n+1];\nint fib(int n) {\n    if (n <= 1) return n;\n    if (memo[n] != 0) return memo[n];\n    return memo[n] = fib(n-1) + fib(n-2);\n}",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "dsa_quiz_1",
              "questionText": "What is the time complexity of accessing an element in an array?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(1)",
              "explanation": "Arrays provide constant-time O(1) access because elements are stored in contiguous memory locations.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_2",
              "questionText": "What is the time complexity of binary search?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Binary search halves the search space each time, resulting in logarithmic time complexity.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_3",
              "questionText": "What data structure uses LIFO (Last In First Out)?",
              "type": "MCQ",
              "options": ["Queue", "Stack", "Array", "Linked List"],
              "correctAnswer": "Stack",
              "explanation": "Stack follows the Last In First Out principle - the last element added is the first one removed.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_4",
              "questionText": "What data structure uses FIFO (First In First Out)?",
              "type": "MCQ",
              "options": ["Queue", "Stack", "Array", "Tree"],
              "correctAnswer": "Queue",
              "explanation": "Queue follows the First In First Out principle - the first element added is the first one removed.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_5",
              "questionText": "What is the time complexity of inserting at the beginning of a linked list?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(1)",
              "explanation": "Inserting at the beginning of a linked list is O(1) because you only need to update the head pointer.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_6",
              "questionText": "What is the worst-case time complexity of quicksort?",
              "type": "MCQ",
              "options": ["O(n)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n)",
              "explanation": "Quicksort's worst case is O(n) when the pivot is always the smallest or largest element.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_quiz_7",
              "questionText": "What is the best-case time complexity of merge sort?",
              "type": "MCQ",
              "options": ["O(n)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Merge sort always has O(n log n) time complexity in all cases.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_quiz_8",
              "questionText": "What is the space complexity of merge sort?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(n)",
              "explanation": "Merge sort requires O(n) auxiliary space for the temporary array during merging.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_quiz_9",
              "questionText": "What is the time complexity of searching in a hash table?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(1)",
              "explanation": "Hash tables provide average O(1) time complexity for search, insert, and delete operations.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_10",
              "questionText": "What is the time complexity of searching in a binary search tree?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Searching in a balanced BST is O(log n) because you eliminate half the tree at each step.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_11",
              "questionText": "What is the time complexity of Dijkstra's algorithm?",
              "type": "MCQ",
              "options": ["O(V)", "O(E)", "O(V log V)", "O(V)"],
              "correctAnswer": "O(V log V)",
              "explanation": "Dijkstra's algorithm with a priority queue has O(V log V + E log V) time complexity, often simplified to O(V log V).",
              "difficulty": "HARD"
            },
            {
              "id": "dsa_quiz_12",
              "questionText": "What is the difference between a tree and a graph?",
              "type": "MCQ",
              "options": ["No difference", "A tree is a connected acyclic graph, a graph can have cycles", "A graph is a connected acyclic tree, a tree can have cycles", "Both are the same"],
              "correctAnswer": "A tree is a connected acyclic graph, a graph can have cycles",
              "explanation": "A tree is a special type of graph that is connected and has no cycles. Graphs can have cycles and may not be connected.",
              "difficulty": "EASY"
            },
            {
              "id": "dsa_quiz_13",
              "questionText": "What is the time complexity of heap sort?",
              "type": "MCQ",
              "options": ["O(n)", "O(n log n)", "O(n)", "O(log n)"],
              "correctAnswer": "O(n log n)",
              "explanation": "Heap sort has O(n log n) time complexity in all cases - O(n) for building the heap and O(n log n) for sorting.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "dsa_quiz_14",
              "questionText": "What is the space complexity of quicksort?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(log n)",
              "explanation": "Quicksort uses O(log n) space for the recursion stack in the average case.",
              "difficulty": "HARD"
            },
            {
              "id": "dsa_quiz_15",
              "questionText": "What is the time complexity of the sieve of Eratosthenes?",
              "type": "MCQ",
              "options": ["O(n)", "O(n log n)", "O(n log log n)", "O(n)"],
              "correctAnswer": "O(n log log n)",
              "explanation": "The sieve of Eratosthenes has O(n log log n) time complexity for finding all primes up to n.",
              "difficulty": "HARD"
            }
          ]
        },
        {
          "id": "dsa_linkedlists",
          "name": "Linked Lists",
          "description": "Linked list data structure and operations",
          "iconUrl": "https://cdn-icons-png.flaticon.com/512/2997/2997321.png",
          "questions": [
            {
              "id": "linkedlist_theory_1",
              "questionText": "What is a linked list?",
              "type": "THEORY",
              "correctAnswer": "A linked list is a linear data structure where elements are stored in nodes, and each node contains a data field and a reference (link) to the next node in the sequence.",
              "explanation": "Unlike arrays, linked lists are not stored in contiguous memory locations. Each node points to the next node, forming a chain.",
              "codeExample": "class Node {\n    int data;\n    Node next;\n    \n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\nclass LinkedList {\n    Node head;\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_theory_2",
              "questionText": "What are the types of linked lists?",
              "type": "THEORY",
              "correctAnswer": "There are three main types: Singly Linked List (each node points to next), Doubly Linked List (each node points to both next and previous), and Circular Linked List (last node points back to first).",
              "explanation": "Singly linked lists are simplest but can only traverse forward. Doubly linked lists allow bidirectional traversal. Circular linked lists are useful for implementing queues and round-robin scheduling.",
              "codeExample": "// Singly Linked List\nNode next;\n\n// Doubly Linked List\nNode next;\nNode prev;\n\n// Circular Linked List\n// last.next = head;",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_theory_3",
              "questionText": "How do you reverse a linked list?",
              "type": "THEORY",
              "correctAnswer": "To reverse a linked list, iterate through the list while maintaining three pointers: prev, current, and next. For each node, reverse the link by setting current.next = prev, then move all pointers forward.",
              "explanation": "The algorithm uses O(1) extra space and O(n) time. We need to be careful to not lose the reference to the rest of the list when reversing links.",
              "codeExample": "Node reverseList(Node head) {\n    Node prev = null;\n    Node current = head;\n    \n    while (current != null) {\n        Node next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n    \n    return prev;\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "linkedlist_theory_4",
              "questionText": "How do you detect a cycle in a linked list?",
              "type": "THEORY",
              "correctAnswer": "Use Floyd's Cycle Detection Algorithm (Tortoise and Hare). Use two pointers - slow moves one step at a time, fast moves two steps. If there's a cycle, they will eventually meet.",
              "explanation": "If fast reaches null, there's no cycle. If slow and fast meet, there's a cycle. To find the cycle's start, reset one pointer to head and move both one step at a time until they meet.",
              "codeExample": "boolean hasCycle(Node head) {\n    Node slow = head;\n    Node fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        \n        if (slow == fast) {\n            return true;\n        }\n    }\n    \n    return false;\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "linkedlist_theory_5",
              "questionText": "How do you find the middle of a linked list?",
              "type": "THEORY",
              "correctAnswer": "Use the two-pointer technique. Initialize slow and fast pointers at head. Move slow one step and fast two steps. When fast reaches the end, slow will be at the middle.",
              "explanation": "This approach finds the middle in a single pass (O(n) time, O(1) space). For even-length lists, slow will be at the first middle element.",
              "codeExample": "Node findMiddle(Node head) {\n    Node slow = head;\n    Node fast = head;\n    \n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    return slow;\n}",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_theory_6",
              "questionText": "How do you merge two sorted linked lists?",
              "type": "THEORY",
              "correctAnswer": "Use a dummy node approach. Compare the heads of both lists, add the smaller node to the result, and move that list's pointer forward. Continue until one list is exhausted, then append the remaining nodes.",
              "explanation": "The dummy node simplifies edge cases. Time complexity is O(n+m) where n and m are lengths of the lists. Space complexity is O(1) for the iterative approach.",
              "codeExample": "Node mergeSortedLists(Node l1, Node l2) {\n    Node dummy = new Node(0);\n    Node current = dummy;\n    \n    while (l1 != null && l2 != null) {\n        if (l1.data < l2.data) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    current.next = (l1 != null) ? l1 : l2;\n    return dummy.next;\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "linkedlist_theory_7",
              "questionText": "What is the difference between array and linked list?",
              "type": "THEORY",
              "correctAnswer": "Arrays provide O(1) random access but O(n) insertion/deletion. Linked lists provide O(n) access but O(1) insertion/deletion at known positions. Arrays have fixed size, linked lists are dynamic.",
              "explanation": "Arrays store elements contiguously in memory, enabling cache locality. Linked lists have scattered memory allocation, which can cause cache misses. Use arrays for frequent access, linked lists for frequent modifications.",
              "codeExample": "// Array - O(1) access, O(n) insert\nint[] arr = new int[10];\narr[5] = 100; // O(1)\n\n// Linked List - O(n) access, O(1) insert\nLinkedList<Integer> list = new LinkedList<>();\nlist.add(100); // O(1) at head",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_theory_8",
              "questionText": "How do you remove the Nth node from the end of a linked list?",
              "type": "THEORY",
              "correctAnswer": "Use two pointers with a gap of N. Move the fast pointer N steps ahead, then move both pointers together until fast reaches the end. The slow pointer will be at the node to remove.",
              "explanation": "This approach finds the node in a single pass. Use a dummy node to handle edge cases where the head needs to be removed. Time complexity is O(n), space is O(1).",
              "codeExample": "Node removeNthFromEnd(Node head, int n) {\n    Node dummy = new Node(0);\n    dummy.next = head;\n    \n    Node fast = dummy;\n    Node slow = dummy;\n    \n    // Move fast n+1 steps ahead\n    for (int i = 0; i <= n; i++) {\n        fast = fast.next;\n    }\n    \n    // Move both until fast reaches end\n    while (fast != null) {\n        slow = slow.next;\n        fast = fast.next;\n    }\n    \n    // Remove the node\n    slow.next = slow.next.next;\n    \n    return dummy.next;\n}",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "linkedlist_quiz_1",
              "questionText": "What is the time complexity of inserting at the beginning of a linked list?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(1)",
              "explanation": "Inserting at the beginning of a linked list is O(1) because you only need to update the head pointer to point to the new node.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_2",
              "questionText": "What is the time complexity of accessing the Nth element in a linked list?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(n)",
              "explanation": "Accessing the Nth element requires traversing from the head, which takes O(n) time in the worst case.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_3",
              "questionText": "Which pointer technique is used to detect a cycle in a linked list?",
              "type": "MCQ",
              "options": ["Two-pointer technique", "Three-pointer technique", "Binary search", "Hashing"],
              "correctAnswer": "Two-pointer technique",
              "explanation": "Floyd's Cycle Detection Algorithm uses two pointers (slow and fast) moving at different speeds to detect cycles.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_4",
              "questionText": "What is the space complexity of reversing a linked list iteratively?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(1)",
              "explanation": "Iterative reversal uses only a few pointers (prev, current, next), so the space complexity is O(1).",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_5",
              "questionText": "In a doubly linked list, each node contains how many pointers?",
              "type": "MCQ",
              "options": ["1", "2", "3", "4"],
              "correctAnswer": "2",
              "explanation": "Each node in a doubly linked list contains two pointers: one to the next node and one to the previous node.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_6",
              "questionText": "What is the time complexity of finding the middle element using two pointers?",
              "type": "MCQ",
              "options": ["O(1)", "O(n)", "O(log n)", "O(n)"],
              "correctAnswer": "O(n)",
              "explanation": "The two-pointer technique traverses the list once, so the time complexity is O(n).",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_7",
              "questionText": "Which data structure is best suited for implementing a browser's back button?",
              "type": "MCQ",
              "options": ["Array", "Linked List", "Stack", "Queue"],
              "correctAnswer": "Stack",
              "explanation": "A stack (which can be implemented using a linked list) is perfect for a browser's back button as it follows LIFO (Last In First Out).",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_8",
              "questionText": "What happens when you try to access an element beyond the length of a linked list?",
              "type": "MCQ",
              "options": ["Returns null", "Throws exception", "Returns 0", "Infinite loop"],
              "correctAnswer": "Returns null",
              "explanation": "When traversing beyond the end of a linked list, you'll eventually reach null, indicating the end of the list.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_9",
              "questionText": "What is the advantage of linked lists over arrays?",
              "type": "MCQ",
              "options": ["Faster access", "Dynamic size", "Less memory", "Cache locality"],
              "correctAnswer": "Dynamic size",
              "explanation": "Linked lists can grow or shrink dynamically as needed, whereas arrays have a fixed size that must be declared upfront.",
              "difficulty": "EASY"
            },
            {
              "id": "linkedlist_quiz_10",
              "questionText": "In a circular linked list, where does the last node point?",
              "type": "MCQ",
              "options": ["null", "head", "middle", "itself"],
              "correctAnswer": "head",
              "explanation": "In a circular linked list, the last node's next pointer points back to the head node, creating a circle.",
              "difficulty": "EASY"
            }
          ]
        }
      ]
    },
    {
      "id": "sql",
      "name": "SQL",
      "description": "Database queries and management",
      "iconUrl": "https://img.icons8.com/color/96/database.png",
      "topics": [
        {
          "id": "sql_basics",
          "name": "SQL Fundamentals",
          "description": "Basic SQL queries",
          "iconUrl": "https://img.icons8.com/color/96/database.png",
          "questions": [
            {
              "id": "sql_theory_1",
              "questionText": "What is the difference between INNER JOIN and LEFT JOIN?",
              "type": "THEORY",
              "correctAnswer": "INNER JOIN returns only matching rows from both tables. LEFT JOIN returns all rows from the left table and matching rows from the right table.",
              "explanation": "INNER JOIN is more restrictive. LEFT JOIN is inclusive - all left table rows appear.",
              "codeExample": "-- INNER JOIN\nSELECT * FROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n\n-- LEFT JOIN\nSELECT * FROM users u\nLEFT JOIN orders o ON u.id = o.user_id;",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "sql_theory_2",
              "questionText": "What is the difference between WHERE and HAVING clauses?",
              "type": "THEORY",
              "correctAnswer": "WHERE filters rows before grouping. HAVING filters groups after aggregation.",
              "explanation": "WHERE works on individual rows and cannot use aggregate functions. HAVING works on grouped results and can use aggregate functions.",
              "codeExample": "-- WHERE - filters before grouping\nSELECT department, COUNT(*)\nFROM employees\nWHERE salary > 50000\nGROUP BY department;\n\n-- HAVING - filters after grouping\nSELECT department, COUNT(*)\nFROM employees\nGROUP BY department\nHAVING COUNT(*) > 5;",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "sql_theory_3",
              "questionText": "What is a foreign key in SQL?",
              "type": "THEORY",
              "correctAnswer": "A foreign key is a field (or collection of fields) in one table that refers to the primary key in another table, establishing a relationship between the two tables.",
              "explanation": "Foreign keys enforce referential integrity, ensuring that relationships between tables remain consistent.",
              "codeExample": "CREATE TABLE orders (\n    id INT PRIMARY KEY,\n    user_id INT,\n    FOREIGN KEY (user_id) REFERENCES users(id)\n);",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "sql_theory_4",
              "questionText": "What is the difference between DELETE and TRUNCATE?",
              "type": "THEORY",
              "correctAnswer": "DELETE removes rows one at a time and can be rolled back. TRUNCATE removes all rows at once, cannot be rolled back, and is faster.",
              "explanation": "DELETE is a DML operation that can use WHERE clause. TRUNCATE is a DDL operation that removes all rows.",
              "codeExample": "-- DELETE - can be rolled back\nDELETE FROM users WHERE id = 1;\n\n-- TRUNCATE - cannot be rolled back\nTRUNCATE TABLE users;",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "sql_theory_5",
              "questionText": "What is the difference between CHAR and VARCHAR?",
              "type": "THEORY",
              "correctAnswer": "CHAR stores fixed-length strings, padding with spaces. VARCHAR stores variable-length strings, using only the space needed.",
              "explanation": "Use CHAR for fixed-length data like codes. Use VARCHAR for variable-length data like names.",
              "codeExample": "CREATE TABLE example (\n    code CHAR(5),      -- Always 5 characters\n    name VARCHAR(100)  -- Up to 100 characters\n);",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "sql_theory_6",
              "questionText": "What is a stored procedure in SQL?",
              "type": "THEORY",
              "correctAnswer": "A stored procedure is a prepared SQL code that you can save and reuse. It can accept parameters and perform complex operations.",
              "explanation": "Stored procedures improve performance, reduce network traffic, and provide security by controlling data access.",
              "codeExample": "CREATE PROCEDURE GetUserById(IN userId INT)\nBEGIN\n    SELECT * FROM users WHERE id = userId;\nEND;\n\n-- Call the procedure\nCALL GetUserById(1);",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "sql_theory_7",
              "questionText": "What is the difference between UNION and UNION ALL?",
              "type": "THEORY",
              "correctAnswer": "UNION removes duplicate rows from the result set. UNION ALL includes all rows, including duplicates.",
              "explanation": "UNION ALL is faster because it doesn't need to check for duplicates. Use UNION when you need unique results.",
              "codeExample": "-- UNION - removes duplicates\nSELECT name FROM employees\nUNION\nSELECT name FROM contractors;\n\n-- UNION ALL - includes duplicates\nSELECT name FROM employees\nUNION ALL\nSELECT name FROM contractors;",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "sql_theory_8",
              "questionText": "What is a transaction in SQL?",
              "type": "THEORY",
              "correctAnswer": "A transaction is a sequence of operations performed as a single logical unit of work. Either all operations succeed, or none do (ACID properties).",
              "explanation": "Transactions ensure data integrity. ACID stands for Atomicity, Consistency, Isolation, Durability.",
              "codeExample": "BEGIN TRANSACTION;\n\nUPDATE account1 SET balance = balance - 100 WHERE id = 1;\nUPDATE account2 SET balance = balance + 100 WHERE id = 2;\n\nCOMMIT; -- or ROLLBACK;",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "sql_quiz_1",
              "questionText": "Which SQL clause is used to filter results?",
              "type": "MCQ",
              "options": ["SELECT", "WHERE", "FROM", "ORDER BY"],
              "correctAnswer": "WHERE",
              "explanation": "The WHERE clause filters rows based on specified conditions.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_2",
              "questionText": "Which SQL keyword is used to sort results?",
              "type": "MCQ",
              "options": ["SORT BY", "ORDER BY", "GROUP BY", "ARRANGE BY"],
              "correctAnswer": "ORDER BY",
              "explanation": "The ORDER BY clause sorts the result set in ascending or descending order.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_3",
              "questionText": "Which SQL function is used to count rows?",
              "type": "MCQ",
              "options": ["SUM()", "COUNT()", "AVG()", "TOTAL()"],
              "correctAnswer": "COUNT()",
              "explanation": "COUNT() returns the number of rows that match a specified criterion.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_4",
              "questionText": "Which JOIN returns all rows from both tables, matching where possible?",
              "type": "MCQ",
              "options": ["INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL OUTER JOIN"],
              "correctAnswer": "FULL OUTER JOIN",
              "explanation": "FULL OUTER JOIN returns all rows from both tables, with NULLs where there's no match.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "sql_quiz_5",
              "questionText": "Which SQL operator is used for pattern matching?",
              "type": "MCQ",
              "options": ["=", "LIKE", "IN", "BETWEEN"],
              "correctAnswer": "LIKE",
              "explanation": "The LIKE operator is used for pattern matching with wildcards % and _.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_6",
              "questionText": "Which SQL clause is used to group rows?",
              "type": "MCQ",
              "options": ["ORDER BY", "GROUP BY", "SORT BY", "CLUSTER BY"],
              "correctAnswer": "GROUP BY",
              "explanation": "The GROUP BY clause groups rows that have the same values into summary rows.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_7",
              "questionText": "What does the DISTINCT keyword do?",
              "type": "MCQ",
              "options": ["Sorts results", "Removes duplicate rows", "Groups results", "Filters results"],
              "correctAnswer": "Removes duplicate rows",
              "explanation": "DISTINCT removes duplicate rows from the result set, returning only unique values.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_8",
              "questionText": "Which SQL statement is used to create a table?",
              "type": "MCQ",
              "options": ["MAKE TABLE", "CREATE TABLE", "NEW TABLE", "BUILD TABLE"],
              "correctAnswer": "CREATE TABLE",
              "explanation": "CREATE TABLE is used to create a new table in the database.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_9",
              "questionText": "Which SQL statement is used to modify data in a table?",
              "type": "MCQ",
              "options": ["CHANGE", "MODIFY", "UPDATE", "ALTER"],
              "correctAnswer": "UPDATE",
              "explanation": "UPDATE is used to modify existing data in a table.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_10",
              "questionText": "Which SQL statement is used to delete data from a table?",
              "type": "MCQ",
              "options": ["REMOVE", "DELETE", "DROP", "ERASE"],
              "correctAnswer": "DELETE",
              "explanation": "DELETE is used to remove rows from a table. DROP removes the entire table.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_11",
              "questionText": "What is the difference between DROP and DELETE?",
              "type": "MCQ",
              "options": ["No difference", "DROP removes the table structure, DELETE removes rows", "DELETE removes the table structure, DROP removes rows", "Both remove rows"],
              "correctAnswer": "DROP removes the table structure, DELETE removes rows",
              "explanation": "DROP removes the entire table including structure. DELETE removes only the data rows.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_12",
              "questionText": "Which SQL function returns the average value?",
              "type": "MCQ",
              "options": ["SUM()", "COUNT()", "AVG()", "MEAN()"],
              "correctAnswer": "AVG()",
              "explanation": "AVG() returns the average value of a numeric column.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_13",
              "questionText": "What is a primary key in SQL?",
              "type": "MCQ",
              "options": ["A key that references another table", "A unique identifier for each row in a table", "A key that allows NULL values", "A key for sorting"],
              "correctAnswer": "A unique identifier for each row in a table",
              "explanation": "A primary key uniquely identifies each row in a table and cannot contain NULL values.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_14",
              "questionText": "Which SQL clause limits the number of rows returned?",
              "type": "MCQ",
              "options": ["TOP", "LIMIT", "MAX", "RESTRICT"],
              "correctAnswer": "LIMIT",
              "explanation": "The LIMIT clause restricts the number of rows returned by a query.",
              "difficulty": "EASY"
            },
            {
              "id": "sql_quiz_15",
              "questionText": "What is the difference between ROLLBACK and COMMIT?",
              "type": "MCQ",
              "options": ["No difference", "ROLLBACK undoes changes, COMMIT saves changes", "COMMIT undoes changes, ROLLBACK saves changes", "Both save changes"],
              "correctAnswer": "ROLLBACK undoes changes, COMMIT saves changes",
              "explanation": "COMMIT saves all changes made in a transaction. ROLLBACK undoes all changes.",
              "difficulty": "EASY"
            }
          ]
        }
      ]
    },
    {
      "id": "data_analysis",
      "name": "Data Analysis",
      "description": "Data analysis, statistics, and visualization",
      "iconUrl": "https://img.icons8.com/color/96/analytics.png",
      "topics": [
        {
          "id": "data_analysis_basics",
          "name": "Data Analysis Fundamentals",
          "description": "Core data analysis concepts",
          "iconUrl": "https://img.icons8.com/color/96/analytics.png",
          "questions": [
            {
              "id": "data_analysis_theory_1",
              "questionText": "What is the difference between mean, median, and mode?",
              "type": "THEORY",
              "correctAnswer": "Mean is the average of all values. Median is the middle value when sorted. Mode is the most frequently occurring value.",
              "explanation": "Mean is sensitive to outliers. Median is robust to outliers. Mode is useful for categorical data.",
              "codeExample": "values = [1, 2, 2, 3, 100]\nmean = sum(values) / len(values)  # 21.6\nmedian = sorted(values)[len//2]  # 2\nmode = most_common(values)  # 2",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_theory_2",
              "questionText": "What is standard deviation?",
              "type": "THEORY",
              "correctAnswer": "Standard deviation measures the amount of variation or dispersion of a set of values. It's the square root of variance.",
              "explanation": "Low standard deviation means values are close to the mean. High standard deviation means values are spread out.",
              "codeExample": "import numpy as np\n\ndata = [1, 2, 3, 4, 5]\nstd_dev = np.std(data)  # 1.414\nvariance = np.var(data)  # 2.0",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_theory_3",
              "questionText": "What is the difference between descriptive and inferential statistics?",
              "type": "THEORY",
              "correctAnswer": "Descriptive statistics summarizes and describes features of a dataset. Inferential statistics makes inferences about a population based on sample data.",
              "explanation": "Descriptive: mean, median, mode, standard deviation. Inferential: hypothesis testing, confidence intervals, regression.",
              "codeExample": "# Descriptive\nmean = np.mean(data)\n\n# Inferential\nfrom scipy import stats\nt_stat, p_value = stats.ttest_ind(sample1, sample2)",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_theory_4",
              "questionText": "What is a p-value in hypothesis testing?",
              "type": "THEORY",
              "correctAnswer": "A p-value is the probability of obtaining results at least as extreme as the observed results, assuming the null hypothesis is true.",
              "explanation": "Small p-values (< 0.05) suggest strong evidence against the null hypothesis. Large p-values suggest weak evidence against it.",
              "codeExample": "from scipy import stats\n\n# Perform t-test\nt_stat, p_value = stats.ttest_1samp(sample, population_mean)\n\nif p_value < 0.05:\n    print(\"Reject null hypothesis\")",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_theory_5",
              "questionText": "What is the difference between Type I and Type II errors?",
              "type": "THEORY",
              "correctAnswer": "Type I error (false positive) is rejecting a true null hypothesis. Type II error (false negative) is failing to reject a false null hypothesis.",
              "explanation": "Type I: convicting an innocent person. Type II: letting a guilty person go free.",
              "codeExample": "# Type I Error: False Positive\n# Actual: No Effect, Concluded: Effect\n\n# Type II Error: False Negative\n# Actual: Effect, Concluded: No Effect",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_theory_6",
              "questionText": "What is correlation?",
              "type": "THEORY",
              "correctAnswer": "Correlation measures the strength and direction of the linear relationship between two variables, ranging from -1 to +1.",
              "explanation": "Correlation of 1 means perfect positive correlation. -1 means perfect negative correlation. 0 means no linear correlation.",
              "codeExample": "import numpy as np\n\nx = [1, 2, 3, 4, 5]\ny = [2, 4, 6, 8, 10]\n\ncorrelation = np.corrcoef(x, y)[0, 1]  # 1.0",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_theory_7",
              "questionText": "What is the difference between correlation and causation?",
              "type": "THEORY",
              "correctAnswer": "Correlation indicates a relationship between variables. Causation means one variable directly affects another. Correlation does not imply causation.",
              "explanation": "Just because two variables are correlated doesn't mean one causes the other. There could be confounding variables or coincidence.",
              "codeExample": "# Correlation: Ice cream sales and drowning incidents increase together\n# Causation: Neither causes the other; both are caused by hot weather\n\n# To prove causation, need controlled experiments",
              "imageUrl": "",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_theory_8",
              "questionText": "What is regression analysis?",
              "type": "THEORY",
              "correctAnswer": "Regression analysis is a statistical method for estimating the relationships between a dependent variable and one or more independent variables.",
              "explanation": "Linear regression fits a line to data points. Multiple regression uses multiple predictors. Logistic regression predicts binary outcomes.",
              "codeExample": "from sklearn.linear_model import LinearRegression\n\nX = [[1], [2], [3], [4], [5]]\ny = [2, 4, 6, 8, 10]\n\nmodel = LinearRegression()\nmodel.fit(X, y)\n\n# y = 2x + 0\nprint(model.coef_)  # [2.]\nprint(model.intercept_)  # 0.0",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            }
          ],
          "quizQuestions": [
            {
              "id": "data_analysis_quiz_1",
              "questionText": "What measure of central tendency is most affected by outliers?",
              "type": "MCQ",
              "options": ["Mean", "Median", "Mode", "Range"],
              "correctAnswer": "Mean",
              "explanation": "Mean is most sensitive to outliers because it uses all values in the calculation.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_2",
              "questionText": "What does a correlation coefficient of 0 indicate?",
              "type": "MCQ",
              "options": ["Perfect positive correlation", "Perfect negative correlation", "No linear correlation", "Weak correlation"],
              "correctAnswer": "No linear correlation",
              "explanation": "A correlation of 0 means there's no linear relationship between the variables.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_3",
              "questionText": "What is the null hypothesis?",
              "type": "MCQ",
              "options": ["The hypothesis that there is an effect", "The hypothesis that there is no effect", "The alternative hypothesis", "The test hypothesis"],
              "correctAnswer": "The hypothesis that there is no effect",
              "explanation": "The null hypothesis (H0) assumes no effect or no difference until proven otherwise.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_4",
              "questionText": "What is a confidence interval?",
              "type": "MCQ",
              "options": ["A range of values that is likely to contain the true population parameter", "A single value estimate", "A hypothesis test", "A probability distribution"],
              "correctAnswer": "A range of values that is likely to contain the true population parameter",
              "explanation": "A 95% confidence interval means we're 95% confident the true parameter lies within that range.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_quiz_5",
              "questionText": "What is the difference between population and sample?",
              "type": "MCQ",
              "options": ["No difference", "Population is the entire group, sample is a subset", "Sample is the entire group, population is a subset", "Both are subsets"],
              "correctAnswer": "Population is the entire group, sample is a subset",
              "explanation": "Population includes all members of a defined group. Sample is a subset selected for analysis.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_6",
              "questionText": "What is variance?",
              "type": "MCQ",
              "options": ["The average of squared deviations from the mean", "The square root of standard deviation", "The middle value", "The most frequent value"],
              "correctAnswer": "The average of squared deviations from the mean",
              "explanation": "Variance measures how far each number in the set is from the mean. Standard deviation is the square root of variance.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_7",
              "questionText": "What is the purpose of data cleaning?",
              "type": "MCQ",
              "options": ["To make data look better", "To remove errors and inconsistencies from data", "To create more data", "To encrypt data"],
              "correctAnswer": "To remove errors and inconsistencies from data",
              "explanation": "Data cleaning involves handling missing values, removing duplicates, correcting errors, and standardizing formats.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_8",
              "questionText": "What is a histogram used for?",
              "type": "MCQ",
              "options": ["To show trends over time", "To show the distribution of a continuous variable", "To compare categories", "To show relationships between variables"],
              "correctAnswer": "To show the distribution of a continuous variable",
              "explanation": "A histogram displays the distribution of a continuous variable by grouping data into bins.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_9",
              "questionText": "What is the difference between bar chart and histogram?",
              "type": "MCQ",
              "options": ["No difference", "Bar chart for categorical data, histogram for continuous data", "Histogram for categorical data, bar chart for continuous data", "Both are the same"],
              "correctAnswer": "Bar chart for categorical data, histogram for continuous data",
              "explanation": "Bar charts display categorical data with gaps between bars. Histograms display continuous data with adjacent bars.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_10",
              "questionText": "What is the interquartile range (IQR)?",
              "type": "MCQ",
              "options": ["The range of the middle 50% of data", "The range of all data", "The average of the data", "The median of the data"],
              "correctAnswer": "The range of the middle 50% of data",
              "explanation": "IQR = Q3 - Q1, where Q1 is the 25th percentile and Q3 is the 75th percentile.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_quiz_11",
              "questionText": "What is an outlier?",
              "type": "MCQ",
              "options": ["A data point that is significantly different from other observations", "The most common value", "The average value", "The middle value"],
              "correctAnswer": "A data point that is significantly different from other observations",
              "explanation": "Outliers are data points that lie an abnormal distance from other values. They can be identified using IQR or z-scores.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_12",
              "questionText": "What is the difference between nominal and ordinal data?",
              "type": "MCQ",
              "options": ["No difference", "Nominal has no order, ordinal has a meaningful order", "Ordinal has no order, nominal has a meaningful order", "Both are the same"],
              "correctAnswer": "Nominal has no order, ordinal has a meaningful order",
              "explanation": "Nominal: categories without order (e.g., colors). Ordinal: categories with order (e.g., ratings).",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_quiz_13",
              "questionText": "What is a scatter plot used for?",
              "type": "MCQ",
              "options": ["To show distribution", "To show relationship between two continuous variables", "To show trends over time", "To compare categories"],
              "correctAnswer": "To show relationship between two continuous variables",
              "explanation": "Scatter plots display the relationship between two continuous variables and can reveal patterns, correlations, or clusters.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_quiz_14",
              "questionText": "What is the difference between supervised and unsupervised learning?",
              "type": "MCQ",
              "options": ["No difference", "Supervised uses labeled data, unsupervised uses unlabeled data", "Unsupervised uses labeled data, supervised uses unlabeled data", "Both use labeled data"],
              "correctAnswer": "Supervised uses labeled data, unsupervised uses unlabeled data",
              "explanation": "Supervised learning learns from labeled examples. Unsupervised learning finds patterns in unlabeled data.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_quiz_15",
              "questionText": "What is overfitting in machine learning?",
              "type": "MCQ",
              "options": ["When a model performs too well", "When a model learns the training data too well and fails to generalize", "When a model is too simple", "When a model has no errors"],
              "correctAnswer": "When a model learns the training data too well and fails to generalize",
              "explanation": "Overfitting occurs when a model memorizes training data instead of learning patterns, resulting in poor performance on new data.",
              "difficulty": "MEDIUM"
            }
          ]
        },
        {
          "id": "data_analysis_advanced",
          "name": "Advanced Data Analysis",
          "description": "Advanced statistical methods and machine learning",
          "iconUrl": "https://img.icons8.com/color/96/analytics.png",
          "questions": [
            {
              "id": "data_analysis_advanced_theory_1",
              "questionText": "What is the difference between parametric and non-parametric tests?",
              "type": "THEORY",
              "correctAnswer": "Parametric tests assume data follows a specific distribution (usually normal). Non-parametric tests don't make distribution assumptions.",
              "explanation": "Parametric: t-test, ANOVA. Non-parametric: Mann-Whitney U, Kruskal-Wallis. Use non-parametric when data isn't normally distributed.",
              "codeExample": "# Parametric - assumes normal distribution\nfrom scipy import stats\nt_stat, p_value = stats.ttest_ind(group1, group2)\n\n# Non-parametric - no distribution assumption\nu_stat, p_value = stats.mannwhitneyu(group1, group2)",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_theory_2",
              "questionText": "What is the Central Limit Theorem?",
              "type": "THEORY",
              "correctAnswer": "The Central Limit Theorem states that the sampling distribution of the mean approaches a normal distribution as the sample size increases, regardless of the population distribution.",
              "explanation": "CLT is fundamental because it allows us to use normal distribution methods even when the population isn't normally distributed, given a large enough sample.",
              "codeExample": "import numpy as np\n\npopulation = np.random.exponential(scale=1, size=10000)\n\n# Take multiple samples and calculate means\nsample_means = [np.mean(np.random.choice(population, 100)) for _ in range(1000)]\n\n# Sample means will be normally distributed\nimport matplotlib.pyplot as plt\nplt.hist(sample_means, bins=30)",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_theory_3",
              "questionText": "What is the difference between R-squared and Adjusted R-squared?",
              "type": "THEORY",
              "correctAnswer": "R-squared measures the proportion of variance explained. Adjusted R-squared penalizes adding unnecessary predictors and is more reliable for comparing models.",
              "explanation": "R-squared always increases with more predictors. Adjusted R-squared only increases if the new predictor improves the model more than expected by chance.",
              "codeExample": "from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\n\nmodel = LinearRegression()\nmodel.fit(X, y)\n\nr_squared = model.score(X, y)\n# Adjusted R-squared\nn = len(y)\np = X.shape[1]\nadj_r_squared = 1 - (1 - r_squared) * (n - 1) / (n - p - 1)",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_theory_4",
              "questionText": "What is the difference between precision and recall?",
              "type": "THEORY",
              "correctAnswer": "Precision measures the accuracy of positive predictions (TP / (TP + FP)). Recall measures the ability to find all positive instances (TP / (TP + FN)).",
              "explanation": "Precision: Of all predicted positive, how many are actually positive? Recall: Of all actual positive, how many did we predict correctly?",
              "codeExample": "from sklearn.metrics import precision_score, recall_score\n\nprecision = precision_score(y_true, y_pred)\nrecall = recall_score(y_true, y_pred)\n\n# F1-score combines both\nfrom sklearn.metrics import f1_score\nf1 = f1_score(y_true, y_pred)",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_theory_5",
              "questionText": "What is the difference between bagging and boosting?",
              "type": "THEORY",
              "correctAnswer": "Bagging trains multiple models independently on random subsets and averages their predictions. Boosting trains models sequentially, each focusing on errors of previous models.",
              "explanation": "Bagging: Random Forest. Boosting: AdaBoost, Gradient Boosting, XGBoost. Bagging reduces variance, boosting reduces bias.",
              "codeExample": "# Bagging - Random Forest\nfrom sklearn.ensemble import RandomForestClassifier\nrf = RandomForestClassifier(n_estimators=100)\n\n# Boosting - Gradient Boosting\nfrom sklearn.ensemble import GradientBoostingClassifier\ngb = GradientBoostingClassifier(n_estimators=100)",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_theory_6",
              "questionText": "What is the difference between bias and variance in machine learning?",
              "type": "THEORY",
              "correctAnswer": "Bias is error from erroneous assumptions. Variance is error from sensitivity to small fluctuations in the training set. There's a trade-off between them.",
              "explanation": "High bias: underfitting (model too simple). High variance: overfitting (model too complex). Goal: find the sweet spot (bias-variance tradeoff).",
              "codeExample": "# High Bias - Underfitting\nmodel = LinearRegression()  # Too simple for complex data\n\n# High Variance - Overfitting\nmodel = DecisionTree(max_depth=None)  # Too complex\n\n# Balanced\nmodel = RandomForestClassifier()  # Good balance",
              "imageUrl": "",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_theory_7",
              "questionText": "What is the difference between A/B testing and multivariate testing?",
              "type": "THEORY",
              "correctAnswer": "A/B testing compares two versions (control vs variant). Multivariate testing tests multiple variables simultaneously to see which combination performs best.",
              "explanation": "A/B testing: simpler, fewer variations. Multivariate: more complex, tests interactions between variables.",
              "codeExample": "# A/B Testing\n# Version A: Original\n# Version B: New design\n# Compare conversion rates\n\n# Multivariate Testing\n# Test headline, color, and button simultaneously\n# Find best combination of all variables",
              "imageUrl": "",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_theory_8",
              "questionText": "What is the difference between time series analysis and cross-sectional analysis?",
              "type": "THEORY",
              "correctAnswer": "Time series analysis studies data collected over time, focusing on trends, seasonality, and patterns. Cross-sectional analysis studies data at a single point in time across different subjects.",
              "explanation": "Time series: stock prices, weather data. Cross-sectional: survey data, census data. Time series requires special techniques to handle autocorrelation.",
              "codeExample": "# Time Series Analysis\nimport pandas as pd\ndf['date'] = pd.to_datetime(df['date'])\ndf.set_index('date', inplace=True)\n\n# Decompose into trend, seasonality, residual\nfrom statsmodels.tsa.seasonal import seasonal_decompose\nresult = seasonal_decompose(df['value'], model='additive')",
              "imageUrl": "",
              "difficulty": "HARD"
            }
          ],
          "quizQuestions": [
            {
              "id": "data_analysis_advanced_quiz_1",
              "questionText": "What is the F1-score?",
              "type": "MCQ",
              "options": ["The average of precision and recall", "The harmonic mean of precision and recall", "The product of precision and recall", "The sum of precision and recall"],
              "correctAnswer": "The harmonic mean of precision and recall",
              "explanation": "F1-score = 2 * (precision * recall) / (precision + recall). It provides a single metric that balances both precision and recall.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_2",
              "questionText": "What is the ROC curve?",
              "type": "MCQ",
              "options": ["A plot of accuracy vs precision", "A plot of true positive rate vs false positive rate", "A plot of recall vs precision", "A plot of bias vs variance"],
              "correctAnswer": "A plot of true positive rate vs false positive rate",
              "explanation": "ROC curve plots TPR (sensitivity) vs FPR (1-specificity) at various threshold settings. AUC measures the overall performance.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_3",
              "questionText": "What is the purpose of cross-validation?",
              "type": "MCQ",
              "options": ["To increase training speed", "To assess how well a model generalizes to unseen data", "To reduce model size", "To increase model accuracy"],
              "correctAnswer": "To assess how well a model generalizes to unseen data",
              "explanation": "Cross-validation splits data into training and validation sets multiple times to get a more reliable estimate of model performance.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_4",
              "questionText": "What is the difference between classification and regression?",
              "type": "MCQ",
              "options": ["No difference", "Classification predicts categories, regression predicts continuous values", "Regression predicts categories, classification predicts continuous values", "Both predict categories"],
              "correctAnswer": "Classification predicts categories, regression predicts continuous values",
              "explanation": "Classification: spam detection, image classification. Regression: price prediction, sales forecasting.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_5",
              "questionText": "What is the difference between clustering and classification?",
              "type": "MCQ",
              "options": ["No difference", "Clustering is unsupervised, classification is supervised", "Classification is unsupervised, clustering is supervised", "Both are supervised"],
              "correctAnswer": "Clustering is unsupervised, classification is supervised",
              "explanation": "Clustering groups similar data points without labels. Classification predicts labels using labeled training data.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_6",
              "questionText": "What is the elbow method used for?",
              "type": "MCQ",
              "options": ["To determine the optimal number of clusters in K-means", "To optimize model parameters", "To detect outliers", "To normalize data"],
              "correctAnswer": "To determine the optimal number of clusters in K-means",
              "explanation": "The elbow method plots within-cluster sum of squares against number of clusters. The 'elbow' point indicates optimal clusters.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_7",
              "questionText": "What is the difference between L1 and L2 regularization?",
              "type": "MCQ",
              "options": ["No difference", "L1 produces sparse models, L2 produces dense models", "L2 produces sparse models, L1 produces dense models", "Both produce sparse models"],
              "correctAnswer": "L1 produces sparse models, L2 produces dense models",
              "explanation": "L1 (Lasso) can drive coefficients to exactly zero, performing feature selection. L2 (Ridge) shrinks coefficients but rarely to zero.",
              "difficulty": "HARD"
            },
            {
              "id": "data_analysis_advanced_quiz_8",
              "questionText": "What is the difference between stochastic gradient descent and batch gradient descent?",
              "type": "MCQ",
              "options": ["No difference", "SGD uses one sample, batch uses all samples", "Batch uses one sample, SGD uses all samples", "Both use all samples"],
              "correctAnswer": "SGD uses one sample, batch uses all samples",
              "explanation": "SGD updates weights after each sample (faster, noisier). Batch updates after all samples (slower, more stable).",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_9",
              "questionText": "What is the purpose of feature scaling?",
              "type": "MCQ",
              "options": ["To increase model size", "To normalize features to similar ranges", "To add more features", "To remove features"],
              "correctAnswer": "To normalize features to similar ranges",
              "explanation": "Feature scaling ensures all features contribute equally to the model. Common methods: Min-Max scaling, Standardization (Z-score).",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_10",
              "questionText": "What is the difference between one-hot encoding and label encoding?",
              "type": "MCQ",
              "options": ["No difference", "One-hot creates binary columns, label encoding uses integers", "Label encoding creates binary columns, one-hot uses integers", "Both are the same"],
              "correctAnswer": "One-hot creates binary columns, label encoding uses integers",
              "explanation": "One-hot encoding creates a binary column for each category. Label encoding assigns each category a unique integer.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_11",
              "questionText": "What is the difference between training set and test set?",
              "type": "MCQ",
              "options": ["No difference", "Training set is for learning, test set is for evaluation", "Test set is for learning, training set is for evaluation", "Both are for evaluation"],
              "correctAnswer": "Training set is for learning, test set is for evaluation",
              "explanation": "Training set teaches the model. Test set evaluates how well the model performs on unseen data.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_12",
              "questionText": "What is the difference between random forest and decision tree?",
              "type": "MCQ",
              "options": ["No difference", "Random forest is an ensemble of decision trees", "Decision tree is an ensemble of random forests", "Both are the same"],
              "correctAnswer": "Random forest is an ensemble of decision trees",
              "explanation": "Random forest combines multiple decision trees to reduce overfitting and improve generalization.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_13",
              "questionText": "What is the purpose of the confusion matrix?",
              "type": "MCQ",
              "options": ["To store model parameters", "To show the performance of a classification model", "To normalize data", "To scale features"],
              "correctAnswer": "To show the performance of a classification model",
              "explanation": "Confusion matrix shows true positives, true negatives, false positives, and false negatives, allowing calculation of various metrics.",
              "difficulty": "EASY"
            },
            {
              "id": "data_analysis_advanced_quiz_14",
              "questionText": "What is the difference between gradient descent and stochastic gradient descent?",
              "type": "MCQ",
              "options": ["No difference", "GD uses all samples, SGD uses one sample", "SGD uses all samples, GD uses one sample", "Both use one sample"],
              "correctAnswer": "GD uses all samples, SGD uses one sample",
              "explanation": "Gradient descent computes gradient using all samples. Stochastic gradient descent uses one random sample per iteration.",
              "difficulty": "MEDIUM"
            },
            {
              "id": "data_analysis_advanced_quiz_15",
              "questionText": "What is the difference between K-means and K-nearest neighbors?",
              "type": "MCQ",
              "options": ["No difference", "K-means is clustering, KNN is classification", "KNN is clustering, K-means is classification", "Both are classification"],
              "correctAnswer": "K-means is clustering, KNN is classification",
              "explanation": "K-means groups data into clusters (unsupervised). KNN classifies new data based on nearest neighbors (supervised).",
              "difficulty": "EASY"
            }
          ]
        }
      ]
    }
  ]
}